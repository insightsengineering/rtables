---
title: "Split Machinery"
author: "Davide Garolini"
date: '`r Sys.Date()`'
output:
  html_document:
    theme: spacelab
    toc: true
    toc_float:
      collapsed: false
editor_options: 
  chunk_output_type: console
knit: (function(inputFile, encoding) {
  rmarkdown::render(inputFile, encoding = encoding, output_dir = ".")})
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

## Disclaimer

Any code or prose which appears in a version of this vignette on the `main` branch of the repository may reflect a specific state of things that can be more or less recent. This guide reflects very important pieces of the split machinery that are unlikely to change. We anyway invite the reader to think always that the current code may have drifted from the following document, and it is always the best practice to read directly the code on `main`.

Please keep in mind that `rtables` is still under active development, and it has seen the efforts of multiple contributors across different years. Therefore, there may be legacy mechanisms and a couple of on-going transformations that could look different in the future.

Being this a working document that may be subjected to both deprecation and updates, we keep `xxx` comments to indicate placeholders for TODOs and warnings that needs further work. 

## Introduction

The scope of this vignette is understanding how `rtables` creates facets by splitting the incoming data into hierarchical groups that go from the root node to singular `rcell`s. The latter level, also called leaf-level, contains the final partition that is subjected to the analysis functions. More details from the user perspective can be found in relevant vignette `vignette("split_functions")` and function documentation like `?split_rows_by` and `?split_funcs`.

The following vignette will describe how the split machinery works for the row domain. Further information on how columns will have a dedicated vignette. 

## Process and Methods

Beforehand, we encourage the reader to familiarize with `vignette("dg_debug_rtables")`. This document is generally valid for R programming, but has been tailored to study and understand complex packages that rely heavily on S3 and S4 object programming like `rtables`.

Here, we explore and study the split machinery with a growing amount of complexity, always following relevant functions and methods throughout their execution. By going from basic to complex and by discussing important and special cases, we hope to be able to give you a good understanding of how the split machinery works. 

In practice, the majority of the split engine resides in the source file `R/split_funs.R` with occasional incursion into `R/make_split_fun.R` for custom split function creation and rarer references to other more general tabulation files.


## `do_split`

The split machinery is so fundamental to `rtables` that relevant functions like `do_split` are executed, even when no split is requested. The following example shows how we can enter `do_split` and start understanding the class hierarchy and the main split engine.

```{r, message=FALSE}
library(rtables)
# debugonce(rtables:::do_split) # Uncomment me to enter the function!!!
basic_table() %>%
    build_table(DM)
```

In the following, we copied it so to allow the reader to go through the general structure with its enhanced comments and sections. Each section in the code reflects roughly a section of this vignette.

```{r, eval=FALSE}
# rtables 6.0.2
### NB This is called at EACH level of recursive splitting
do_split <- function(spl,
                     df,
                     vals = NULL,
                     labels = NULL,
                     trim = FALSE,
                     spl_context) {
# CHECKS #
    ## This will error if, e.g., df does not have columns
    ##  required by spl, or generally any time the split (spl)
    ##  can not be applied to df
    check_validsplit(spl, df)
    
# SPLIT FUNCTION #
    ## In special cases, we need to partition data (split)
    ##  in a very specific way, e.g. depending on the data or 
    ##  external values. These can be achieved by using a custom
    ##  split function.
    
    ## note the <- here!!!
    if(!is.null(splfun <- split_fun(spl))) {
        ## Currently the contract is that split_functions take df, vals, labels and
        ## return list(values=., datasplit=., labels = .), optionally with
        ## an additional extras element
        if(func_takes(splfun, ".spl_context")) {
            ret <- tryCatch(splfun(df, spl, vals, labels, trim = trim,
                                   .spl_context = spl_context),
                            error = function(e) e) ## rawvalues(spl_context ))
        } else {
            ret <- tryCatch(splfun(df, spl, vals, labels, trim = trim),
                            error = function(e) e)
        }
        if(is(ret, "error")) {
            stop("Error applying custom split function: ", ret$message, "\n\tsplit: ",
                 class(spl), " (", payloadmsg(spl), ")\n",
                 "\toccured at path: ",
                 spl_context_to_disp_path(spl_context), "\n")
        }
    } else {
# .apply_split_inner #
        ## This is called when no split function is provided. Please note that also when provided,
        ##  this function will be probably called, as far as the main splitting method is not willingly
        ##  modified by the split function.
        ret <- .apply_split_inner(df = df, spl = spl, vals = vals, labels = labels, trim = trim)
    }

# EXTRA #
    ## this adds .ref_full and .in_ref_col
    if(is(spl, "VarLevWBaselineSplit"))
        ret <- .add_ref_extras(spl, df, ret)

# FIXUPVALS #
    ## this:
    ## - guarantees that ret$values contains SplitValue objects
    ## - removes the extras element since its redundant after the above
    ## - Ensures datasplit and values lists are named according to labels
    ## - ensures labels are character not factor
    ret <- .fixupvals(ret)
    
# RETURN #
    ret
}
```
We will see how input parameters are used and where. The most important ones are `spl` and `df`: the split objects and the input `data.frame`.


### Checks and Classes

We will start by looking at the first function called from `do_split`. This may give us a good overview of how the split itself is defined. This is, of course, the check-function (`check_validsplit`) that is used to verify if the split is valid for the data. In the following we will describe step-by-step the split-class hierarchy, but we invite the reader to explore this autonomously in future occasions. 

Lets then search the package for `check_validsplit`, you will find that it is defined as a generic in `R/split_funs.R`, where it is applied to the following "split" classes: `VarLevelSplit`, `MultiVarSplit`, `VAnalyzeSplit`, `CompoundSplit`, and `Split`. Another way to find this information, which is more useful for more spread out and complicated objects, is using `showMethods(check_validsplit)`. The virtual class `VAnalyzeSplit` (convention: it starts with "V") defines the main parent of analysis split which we discuss in detail in related vignette `vignette()` (xxx). From this, we can intuit that the `analyze()` calls actually mimic split objects as they create different results under a specific final split (or node). Now, notice that `check_validsplit` is also called in another location, i.e. in the main `R/tt_dotabulation.R` source file. This is again something related to making the "analyze" rows as it mainly checks for `VAnalyzeSplit` (link to tabulation dev guide xxx). We will discuss the other classes when they will appear in our examples (link to class hierarchy xxx). 

For the moment, we see with `class(spl)` (from the main `do_split` function) that we are dealing with an `AllSplit` object. By calling `showMethods(check_validsplit)` we will produce the following: 

```
# rtables 6.0.2
Function: check_validsplit (package rtables)
spl="AllSplit"
    (inherited from: spl="Split")
spl="CompoundSplit"
spl="MultiVarSplit"
spl="Split"
spl="VAnalyzeSplit"
spl="VarLevelSplit"
```
It means that each of the listed classes has a dedicated definition of `check_validsplit` that may largely differ from the others. Only the class `AllSplit` does not have its own function definition as it is inherited from the `Split` class. Therefore, we understand that `AllSplit` is a class parent of `Split`. This is one of the first definition of a virtual class in the package and it is the only one that does not present the "V" prefix. Any of these classes are defined along with their constructor in `R/00tabletrees.R`. Reading how `AllSplit` is structured can be an useful example to understand how split objects are expected to work. Please see the comments in the following:

```{r, eval=FALSE}
# rtables 6.0.2
setClass("AllSplit", contains = "Split")

AllSplit <- function(split_label = "",
                    cfun = NULL,
                    cformat = NULL,
                    cna_str = NA_character_,
                    split_format = NULL,
                    split_na_str = NA_character_,
                    split_name = NULL,
                    extra_args = list(),
                    indent_mod = 0L,
                    cindent_mod = 0L,
                    cvar = "",
                    cextra_args = list(),
                    ...) {
    if(is.null(split_name)) { # If the split has no name
        if(nzchar(split_label)) # (std is "")
            split_name <- split_label 
        else
            split_name <- "all obs" # Nor label, a standard split with all 
                                    # observations is assigned.
    }
    new("AllSplit", split_label = split_label,
        content_fun = cfun,
        content_format = cformat,
        content_na_str = cna_str,
        split_format = split_format,
        split_na_str = split_na_str,
        name = split_name,
        label_children = FALSE,
        extra_args = extra_args,
        indent_modifier = as.integer(indent_mod),
        content_indent_modifier = as.integer(cindent_mod),
        content_var = cvar,
        split_label_position = "hidden",
        content_extra_args = cextra_args,
        page_title_prefix = NA_character_,
        child_section_div = NA_character_)
}
```

We can see also print this information by calling `getClass("AllSplit")` for the general slot definition, or by calling `getClass(spl)` for having also all the values. Note that the first call will give also a lot of information about the class hierarchy. For more information regarding class hierarchy, please refer to the relevant vignette (xxx). We will discuss the majority of the slots by the end of this document. Now lets see if we can find some of the values described in the constructor in our object. To do so we will show here the more compact representation given by `str`. When there are multiple and hierarchical slots that contain objects themselves, calling `str` will be much less informative or not at all informative if the maximum level of nesting is not set (e.g. `max.level = 2`).

```{r, eval=FALSE}
# rtables 6.0.2
Browse[2]> str(spl, max.level = 2)
Formal class 'AllSplit' [package "rtables"] with 17 slots
  ..@ payload                : NULL
  ..@ name                   : chr "all obs"
  ..@ split_label            : chr ""
  ..@ split_format           : NULL
  ..@ split_na_str           : chr NA
  ..@ split_label_position   : chr "hidden"
  ..@ content_fun            : NULL
  ..@ content_format         : NULL
  ..@ content_na_str         : chr NA
  ..@ content_var            : chr ""
  ..@ label_children         : logi FALSE
  ..@ extra_args             : list()
  ..@ indent_modifier        : int 0
  ..@ content_indent_modifier: int 0
  ..@ content_extra_args     : list()
  ..@ page_title_prefix      : chr NA
  ..@ child_section_div      : chr NA
```

Details about these slots will be necessary in future examples, and we will deal with them at that time. Now, we gave you a hint of the complex class hierarchy that makes up `rtables`, and how to explore it autonomously. Lets go forward in `do_split`. In our case, being `AllSplit` inherited from `Split`, we are sure that the called function will be the following (read the comment!):

```{r, eval=FALSE}
# rtables 6.0.2
## default does nothing, add methods as they become
## required
setMethod("check_validsplit", "Split",
          function(spl, df)
    invisible(NULL))
```

### Split function and `.apply_split_inner`

Before diving into custom split functions we need to take a moment to analyze how `.apply_split_inner` works. This function is routinely called, also in the case we do have a split function. Lets see why this can be the case by entering it with `debugonce(.apply_split_inner)`. Of course, we are still browsing `do_split` in debug mode from the first example. We printed and commented it in the following:

```{r, eval=FALSE}
# rtables 6.0.2
.apply_split_inner <- function(spl, df, vals = NULL, labels = NULL, trim = FALSE) {
    # - INPUTS - #
    # In this case .applysplit_rawvals will attempt finding the split values if vals is NULL.
    # Please notice that they might be a non-mutually exclusive set or subset of elements that
    # will constitute the split.
    
    # - SPLIT VALS - # 
    ## try to calculate values first. Most of the time we can
    if(is.null(vals))
        vals <- .applysplit_rawvals(spl, df)
    
    # - EXTRA PARAMETERS - #
    # This call extracts extra parameters from the split, according to the split values
    extr <- .applysplit_extras(spl, df, vals)

    # If there are no values to do the split upon, we return an empty final split
    if(is.null(vals)) {
        return(list(values = list(),
                    datasplit = list(),
                    labels = list(),
                    extras = list()))
    }

    # - DATA SUBSETTING - #
    dpart <- .applysplit_datapart(spl, df, vals)

    # - LABEL RETRIEVAL - #
    if(is.null(labels))
        labels <- .applysplit_partlabels(spl, df, vals, labels)
    else
        stopifnot(names(labels) == names(vals))
    
    # - TRIM - #
    ## get rid of columns that would not have any
    ## observations.
    ##
    ## But only if there were any rows to start with
    ## if not we're in a manually constructed table
    ## column tree
    if(trim) {
        hasdata <- sapply(dpart, function(x) nrow(x) > 0)
        if(nrow(df) > 0 && length(dpart) > sum(hasdata)) { #some empties
            dpart <- dpart[hasdata]
            vals <- vals[hasdata]
            extr <- extr[hasdata]
            labels <- labels[hasdata]
        }
    }

    # - ORDER RESULTS - #
    # Finds relevant order depending on spl_child_order()
    if(is.null(spl_child_order(spl)) || is(spl, "AllSplit")) {
        vord <- seq_along(vals)
    } else {
        vord <- match(spl_child_order(spl),
                     vals)
        vord <- vord[!is.na(vord)]
    }


    ## FIXME: should be an S4 object, not a list
    ret <- list(values = vals[vord],
               datasplit = dpart[vord],
               labels = labels[vord],
               extras = extr[vord])
    ret
}
```

After reading `.apply_split_inner`, we see that there are some fundamental functions, defined strictly for internal use (convention: they start with ".") that are generics and depend on the kind of split in input. `R/split_funs.R` is very kind and group their generic definition at the beginning of the file. These functions are the main dispatcher for the majority of the split machinery. This is a clear example that shows how using `S4` logic helps clarity and flexibility in programming, allowing for easy extension of the program. For compactness we show also the `showMethods` result for each generic.

```{r, eval=FALSE}
# rtables 6.0.2
# Retrieves the values that will constitute the splits (facets), not necessarily a unique list.
# They could come from the data cuts for example -> it can be anything if it produces a set of strings.
setGeneric(".applysplit_rawvals", 
           function(spl, df) standardGeneric(".applysplit_rawvals"))
# Browse[2]> showMethods(.applysplit_rawvals)
# Function: .applysplit_rawvals (package rtables)
# spl="AllSplit"
# spl="ManualSplit"
# spl="MultiVarSplit"
# spl="VAnalyzeSplit"
# spl="VarLevelSplit"
# spl="VarStaticCutSplit"
# Nothing here is inherited from the virtual class Split!!!

# Contains the subset of the data (default, but these can overlap, can also NOT be mutually exclusive).
setGeneric(".applysplit_datapart",
           function(spl, df, vals) standardGeneric(".applysplit_datapart"))
# Same as .applysplit_rawvals

# Extract the extra parameter for the split
setGeneric(".applysplit_extras",
           function(spl, df, vals) standardGeneric(".applysplit_extras"))
# Browse[2]> showMethods(.applysplit_extras)
# Function: .applysplit_extras (package rtables)
# spl="AllSplit"
#     (inherited from: spl="Split")
# spl="Split"
# This means there is only a function for the virtual class Split. 
#  So all splits behaves the same!!!

# Split label retrieval and assignment if visible.
setGeneric(".applysplit_partlabels",
           function(spl, df, vals, labels) standardGeneric(".applysplit_partlabels"))
# Browse[2]> showMethods(.applysplit_partlabels)
# Function: .applysplit_partlabels (package rtables)
# spl="AllSplit"
#     (inherited from: spl="Split")
# spl="MultiVarSplit"
# spl="Split"
# spl="VarLevelSplit"

setGeneric("check_validsplit", # our friend 
           function(spl, df) standardGeneric("check_validsplit"))
# Note: check_validsplit is an internal function but it is not excluded that one
#       day it will be exported. That is way it does not have the "." prefix.

setGeneric(".applysplit_ref_vals",
          function(spl, df, vals) standardGeneric(".applysplit_ref_vals"))
# Browse[2]> showMethods(.applysplit_ref_vals)
# Function: .applysplit_ref_vals (package rtables)
# spl="Split"
# spl="VarLevWBaselineSplit"

```

Now, we know that `.applysplit_extras` is the function that will be called first because we did not specify any `vals` and it is therefore `NULL`. This is a generic function as it can be seen by `showMethod(.applysplit_extras)`. It is indeed an `S4` generics and its source code can be determined by the following:

```{r, eval=FALSE}
# rtables 6.0.2
Browse[3]> getMethod(".applysplit_rawvals", "AllSplit")
Method Definition:

function (spl, df) 
obj_name(spl)

Signatures:
        spl       
target  "AllSplit"
defined "AllSplit"

# What is obj_name -> slot in spl
Browse[3]> obj_name(spl)
[1] "all obs"

# coming from
Browse[3]> getMethod("obj_name", "Split")
Method Definition:

function (obj) 
obj@name ##### Slot that we could see from str(spl, max.level = 2)

Signatures:
        obj    
target  "Split"
defined "Split"
```

Then we have `.applysplit_extras` that will be covered in later sections and simply extracts the extra arguments from the split objects and assign them to their relative split values. If no split values are still available, the function will exit here with an empty split. Otherwise the data will be divided in different splits or data subsets (facets) with `.applysplit_datapart`. In our current example the resulting list comprises the whole input data set (i.e. do `getMethod(".applysplit_datapart", "AllSplit")` and a list will be evident: `function (spl, df, vals) list(df)`).

Next, split labels are checked. If they are not present split values (`vals`) will be used with `.applysplit_partlabels` that, in the case of it being applied to a `Split` object, it translates into `as.character(vals)`. Otherwise, the inserted labels are checked against the name of split values.

Lastly, the split values are ordered on the basis of `spl_child_order`. In our case, which concerns the general `AllSplit`, the sorting will not happen, i.e. it will be simply dependent on the number of split values `seq_along(vals)`.

#### A simple split

In the following, we demonstrate how row splits work according to the features that we have already described. We add two splits and see how `do_split` behavior changes. Note that if we do not add an `analyze` call, the split will behave as before, giving an empty table with all observations. As default, calling `analyze` on a variable will produce a mean for each data subset that has been generated by the splits. We want to go beyond the first call of `do_split` that is by design on all observation with the purpose of generating the root split that contains all data and all the splits (indeed `AllSplit`). To achieve this goal we can use `debug(rtables:::do_split)` instead of `debugonce(rtables:::do_split)` as we will need to step in each of the splits. Alternatively, it is possible to use the more powerful `trace` function to enter specifically in the case the input is from a specific class. To do so the following can be used: `trace("do_split", quote(if(!is(spl, "AllSplit")) browser()), where = asNamespace("rtables"))`. Note that we had to specify the namespace with where. Multiple tracer elements can be added with `expression(E1, E2)` which is the same as `c(quote(E1), quote(E2))`. Specific steps can be specified with the `at` parameter. Remember to do `untrace("do_split", quote(if(!is(spl, "AllSplit")) browser()), where = asNamespace("rtables"))` to remove it.

```{r, message=FALSE}
# rtables 6.0.2
library(rtables)
library(dplyr)

# This filter is added to avoid having too many calls to do_split
DM_tmp <- DM %>% 
    filter(ARM %in% names(table(DM$ARM)[1:2])) %>% # limit to two
    filter(SEX %in% c("M", "F")) %>% # limit to two
    mutate(SEX = factor(SEX), ARM = factor(ARM)) # to drop unattended levels

# debug(rtables:::do_split)
lyt <- basic_table() %>%
    split_rows_by("ARM") %>% 
    split_rows_by("SEX") %>% 
    analyze("BMRKR1") # analyze() is needed for the table to have non-label rows

lyt %>% 
    build_table(DM_tmp)
# undebug(rtables:::do_split)
```

Now, we might want to check the formal class of `spl` before anything else.

```{r, eval=FALSE}
# rtables 6.0.2
Browse[2]> str(spl, max.level = 2)
Formal class 'VarLevelSplit' [package "rtables"] with 20 slots
  ..@ value_label_var        : chr "ARM"
  ..@ value_order            : chr [1:2] "A: Drug X" "B: Placebo"
  ..@ split_fun              : NULL
  ..@ payload                : chr "ARM"
  ..@ name                   : chr "ARM"
  ..@ split_label            : chr "ARM"
  ..@ split_format           : NULL
  ..@ split_na_str           : chr NA
  ..@ split_label_position   : chr "hidden"
  ..@ content_fun            : NULL
  ..@ content_format         : NULL
  ..@ content_na_str         : chr NA
  ..@ content_var            : chr ""
  ..@ label_children         : logi NA
  ..@ extra_args             : list()
  ..@ indent_modifier        : int 0
  ..@ content_indent_modifier: int 0
  ..@ content_extra_args     : list()
  ..@ page_title_prefix      : chr NA
  ..@ child_section_div      : chr NA
```

From this, we can directly infer that the class is different now (`VarLevelSplit`) and understand that the split label will be hidden (`split_label_position` slot). Moreover, we see a specific value order with specific split values. Also, `VarLevelSplit` seems to have three more slots than `AllSplit`. What are they precisely?

```{r, eval=FALSE}
# rtables 6.0.2
slots_as <- getSlots("AllSplit") # inherits virtual class Split and is general class for all splits
# getClass("CustomizableSplit") # -> Extends: "Split", Known Subclasses: Class "VarLevelSplit", directly
slots_cs <- getSlots("CustomizableSplit") # Adds split function
slots_vls <- getSlots("VarLevelSplit")

slots_cs[!(names(slots_cs) %in% names(slots_as))]
#        split_fun 
# "functionOrNULL" 
slots_vls[!(names(slots_vls) %in% names(slots_cs))]
# value_label_var     value_order 
#     "character"           "ANY"
```

Remember always to check the constructor and class definition inside `R/00tabletrees.R` if exploratory tools do not suffice. Now, `check_validsplit(spl, df)` will dispatch to a different method than before (`getMethod("check_validsplit", "VarLevelSplit")`). Indeed, it uses the internal utility function `.checkvarsok` to check if the `vars`, i.e. the `payload` is actually present in `names(df)`.

Now, the next relevant function will be `.apply_split_inner` where we want to see exactly what changes (`debugonce(.apply_split_inner)`). Of course, this function is directly called as no custom split function is provided. Being parameter `vals` not specified (`NULL`), the split values are retrieved from `df` by using the split payload to select specific columns (`varvec <- df[[spl_payload(spl)]]`). Every time no split values are specified, they will be retrieved from the selected column as unique values, if character, or levels, if factor. 

Next, `.applysplit_datapart` creates a named list of facets or data subsets. In this case, the result is actually a mutually exclusive partition of the data. This is because we did not specify any split values and the column content was used as such with unique call in case of a character vector or levels in case of factors. `.applysplit_partlabels` is a bit less linear as it has to take into account the possibility of having specified labels in the payload. Beside looking at the function source code with `getMethod(".applysplit_partlabels", "VarLevelSplit")`, we can enter in debugging mode the `S4` generic function as follows:

```{r, eval=FALSE}
# rtables 6.0.2
eval(debugcall(.applysplit_partlabels(spl, df, vals, labels)))
# We leave to the smart developer to see how the labels are assigned

# PS: remember to undebugcall() similarly
```

In our case, the final labels are `vals` because they were not assigned. Their order is retrieved from the split object (`spl_child_order(spl)`) and matched with current split values. The returned list is then processed as it was before.

If we continue with the next call of `do_split`, the same procedure is accomplished for the second `ARM` split. This is done on the partition that was already done in the first split. The only give out of this is the fact that the main `df` is constituted by a subset (facet) of the total data, according to the first split. This will be done iteratively for as many data split as requested. Before concluding this iteration, we take a moment to talk a bit more in detail about how `.fixupvals(partinfo)` works. It is not a generic function and the source code can be easily accessed as follows. We suggest to run through it with `debugonce(.fixupvals)` to understand what it does in practice. The fundamental aspects are listed in the following:

* Ensures that labels are character and not factor.
* Ensures that the splits of data and list of values are named according to labels.
* Guarantees that `ret$values` contains `SplitValue` objects.
* Removes the list element `extra` since its now included in the `SplitValue`.

Note that this function can occasionally be called more than once on the same return object (a named list for now). Of course, after the first call only checks are applied.

```{r, eval=FALSE}
# rtables 6.0.2
   
# Can find the following core function:
# vals <- make_splvalue_vec(vals, extr, labels = labels)
# ---> Main list of SplitValue objects: iterative call of 
#      new("SplitValue", value = val, extra = extr, label = label)

# Structure of ret before the function call
Browse[2]> str(ret, max.level = 2)
List of 4
 $ values   : chr [1:2] "A: Drug X" "B: Placebo"
 $ datasplit:List of 2
  ..$ A: Drug X : tibble [121 × 8] (S3: tbl_df/tbl/data.frame)
  ..$ B: Placebo: tibble [106 × 8] (S3: tbl_df/tbl/data.frame)
 $ labels   : Named chr [1:2] "A: Drug X" "B: Placebo"
  ..- attr(*, "names")= chr [1:2] "A: Drug X" "B: Placebo"
 $ extras   :List of 2
  ..$ : list()
  ..$ : list()
  
# Structure of ret after the function call
Browse[2]> str(.fixupvals(ret), max.level = 2)
List of 3
 $ values   :List of 2
  ..$ A: Drug X :Formal class 'SplitValue' [package "rtables"] with 3 slots
  ..$ B: Placebo:Formal class 'SplitValue' [package "rtables"] with 3 slots
 $ datasplit:List of 2
  ..$ A: Drug X : tibble [121 × 8] (S3: tbl_df/tbl/data.frame)
  ..$ B: Placebo: tibble [106 × 8] (S3: tbl_df/tbl/data.frame)
 $ labels   : Named chr [1:2] "A: Drug X" "B: Placebo"
  ..- attr(*, "names")= chr [1:2] "A: Drug X" "B: Placebo"
 
# The SplitValue object is fundamental
Browse[2]> str(ret$values)
List of 2
 $ A: Drug X :Formal class 'SplitValue' [package "rtables"] with 3 slots
  .. ..@ extra: list()
  .. ..@ value: chr "A: Drug X"
  .. ..@ label: chr "A: Drug X"
 $ B: Placebo:Formal class 'SplitValue' [package "rtables"] with 3 slots
  .. ..@ extra: list()
  .. ..@ value: chr "B: Placebo"
  .. ..@ label: chr "B: Placebo"
```


#### Included split functions

We start with a custom split function that is already defined in `rtables`. Its scope is filtering out specific values as follows:

```{r, message=FALSE}
library(rtables)
# debug(rtables:::do_split) # uncomment to see into the main split function
basic_table() %>%
    split_rows_by("SEX", split_fun = drop_split_levels) %>% 
    analyze("BMRKR1") %>%
    build_table(DM)
# undebug(rtables:::do_split)

# PS: this produces the same output as before with the filters
```

After skipping the root split, we enter the split based on column `SEX`. As we specified a split function, we retrieve the split function by using `splfun <- split_fun(spl)` and enter an `if-else` statement for the two possible cases where there is split contenxt or not. In both cases, an error catching framework is used so to give informative errors in case of failure. Later we will see better how it works.

Here, we invite to always keep a keen eye on `spl_context`, as it is fundamental for more sophisticate splits, e.g. in the cases where the split itself depends mainly on preceding splits or values. Please, when the split function is called, take a moment to look at how `drop_split_levels` is defined. You will see that it is fundamentally a wrapper of `.apply_split_inner` that drops empty factor levels, therefore avoiding empty split.

```{r, eval=FALSE}
# rtables 6.0.2
> drop_split_levels
function(df,
         spl,
         vals = NULL,
         labels = NULL,
         trim = FALSE) {
    # Retrieve split column
    var <- spl_payload(spl)
    df2 <- df
    
    ## This call is exactly the one we did in the filtering to get rid of empty levels
    df2[[var]] <- factor(df[[var]])
    
    ## Our main function!
    .apply_split_inner(spl, df2, vals = vals,
                       labels = labels,
                       trim = trim)
}
```

There are many split functions already included in `rtables`. Lists of them can be found in `vignette("split_functions")`, `?split_funcs`, and `vignette("advanced_usage")`. We leave to the smart developer finding in detail how some of these work, in particular `trim_levels_to_map`.

#### Custom split functions

Now we try to create our custom split function. Firstly, we will see how the system manages error messages. For a general understanding of how we can provide custom split functions, please read `?custom_split_funs` in detail. In the following we use browser() to enter our custom split functions. For the error cases, we invite the reader to activate `options(error = recover)` so to investigate the cases where we have an error. Note that you can retrieve original behavior by restarting `R` session or by caching the default option value. Another smart possibility is to use `callr` to retrieve the default as follows: `default_opts <- callr::r(function(){options()}); options(error = default_opts$error)`.

```{r}
# rtables 6.0.2
# Table call with only function changing
simple_table <- function(DM, f){
    lyt <- basic_table() %>% 
        split_rows_by("ARM", split_fun = f) %>% 
        analyze("BMRKR1")
    
    lyt %>% 
        build_table(DM)
}
# First round will fail because there are unused arguments
exploratory_split_fun <- function(df, spl) NULL
# debug(rtables:::do_split)
err_msg <- tryCatch(simple_table(DM, exploratory_split_fun), error = function(e) e)
# undebug(rtables:::do_split)

message(err_msg$message)
```

Commented debugging options can get you above and before the error. Nonetheless using the recover option will get you the possibility to select the frame number, i.e. the trace level to enter as debugging selecting the last one (10 in my case), will allow you to see the value of `ret` from `rtables:::do_split` that is the simple error and how the informative error message that follows is created.

```{r, eval=FALSE}
# rtables 6.0.2
# Debugging level
10: tt_dotabulation.R#627: do_split(spl, df, spl_context = spl_context)

# Original call and final error
> simple_table(DM, exploratory_split_fun)
Error in do_split(spl, df, spl_context = spl_context) : 
  Error applying custom split function: unused arguments (vals, labels, trim = trim) # This is main error
	split: VarLevelSplit (ARM) # Split reference
	occured at path: root # Path level (where it happened)
```

The previous split function fails because not all arguments are present. A simple way to avoid this is to add `...` to the function call. Now lets construct an interesting split function (and error):

```{r}
# rtables 6.0.2
f_brakes_if <- function(split_col = NULL, error = FALSE){
    function(df, spl, ...){ # order matters! more than naming
        # browser() # To check how it works
        if (is.null(split_col)) { # Retrieves the default
            split_col <- spl_variable(spl) # Internal accessor to split obj
        }
        my_payload <- split_col # Changing split column value
        
        vals <- levels(df[[my_payload]]) # Extracting values to split
        datasplit <- lapply(seq_along(vals), function(i) {
            df[df[[my_payload]] == vals[[i]], ]
        })
        names(datasplit) <- as.character(vals)
        
        # Fantasy error
        if (isTRUE(error)) {
            # browser() # If you need to check how it works
            mystery_error_values <- sapply(datasplit, function(x) mean(x$BMRKR1))
            if (any(mystery_error_values > 6)) {
                stop("It should not be more than 6! Should it be? Found in split values: ",
                     names(datasplit)[which(mystery_error_values > 6)])
            }
        }
        
        # Handy function to return a split result!!
        make_split_result(vals, datasplit, vals)
    }
}
simple_table(DM, f_brakes_if()) # works!
simple_table(DM, f_brakes_if(split_col = "STRATA1")) # works!

# Does not work, but in an informative way
# simple_table(DM, f_brakes_if(error = TRUE))

# Error in do_split(spl, df, spl_context = spl_context) :
# Error applying custom split function: It should not be more than 6! Should it be? Found in split values: B: Placebo
# split: VarLevelSplit (ARM)
# occured at path: root
```

Now we will dwell a moment to the relatively new machinery to create custom split functions. Before doing so, please read the relevant documentation `?make_split_fun`. The majority of functions already included in `rtables` can be or will be written with `make_split_fun` as it is a more stable constructor for such functions. We invite the reader to take a look at `make_split_fun.R`. The majority of functions should be very understandable as far as you got into this guide. We want to highlight that if no core split function is specified, which is commonly the case, `make_split_fun` calls directly `do_base_split` which is a minimal wrapper of our well known `do_split`. `drop_facet_levels` for example is a pre-processing function that at the core simply removes empty factor levels from the split "column", thus avoiding empty lines to be shown. 

It is possible, also to add a list of functions, as it can be seen in the examples of `?make_split_fun`. Note that pre and post processing need a list in input to support the possibility to combine multiple functions. The core splitting function, instead, must be a single function call as it is not expected to have stacked features. This needs rarely to be modified and the majority of the included split functions work with pre or post processing. Included post-processing functions are interesting as they interact with the split object, e.g. by reordering the facets or by adding an overall facet (`add_overall_facet`). The smart reader will have noticed as the core function rely somehow on `do_split` and many of the post processing functions rely on `make_split_result` which is the best way to get the correct split return structure. Note that modifying the core split works only in the row space at the moment.

#### `.spl_context` - a bit of context to our splits
The best way to understand what split context does and how to use it is to read relevant vignette (xxx advanced usage), and to use `browser()` a split function to see how it is structured. As `.spl_context` is needed for rewriting core functions, we propose here a wrapper of `do_base_split`, which is a handy redirection to the standard `do_split` without
the split function part, i.e. it is a wrapper of `.apply_split_inner`, the real core splitting machinery. For curiosity we set here `trim = TRUE`. This trimming works only when there is a mixed table (some values are 0s and some have content, there it trims the 0s). This is rarely the case and we encourage using the replacement functions `trim_levels_to_group` and `trim_levels_to_map`. Nowadays, it should even be impossible to set it differently from `trim = FALSE`.

(write an issue informative error for not list xxx).
```{r, eval=FALSE}
# rtables 6.0.2
browsing_f <- function(df, spl, .spl_context, ...) {
    # browser()
    # do_base_split(df, spl, ...) # order matters!! This would fail if done
    do_base_split(spl = spl, df = df, vals = NULL, labels = NULL, trim = TRUE)
}
fnc_tmp <- function(innervar) { # Exploring trim_levels_in_facets (check its form)
    function(ret, ...) {
            # browser()
            for(var in innervar) { # of course AGE is not here, so nothing is dropped!!
                ret$datasplit <- lapply(ret$datasplit, function(df) {
                    df[[var]] <- factor(df[[var]])
                    df
                })
            }
            ret
        }
}
basic_table() %>% 
    split_rows_by("ARM") %>% 
    split_rows_by("STRATA1") %>% 
    split_rows_by_cuts("AGE", cuts = c(0, 50, 100),
                  cutlabels = c("young", "old")) %>% 
    split_rows_by("SEX", split_fun = make_split_fun(
        pre = list(drop_facet_levels), # This is dropping the sex levels (age is upper level)
        core_split = browsing_f,
        post = list(fnc_tmp("AGE")) # To drop these we should use a split_fun in the above level for that
    )) %>% 
    summarize_row_groups() %>% 
    build_table(DM)

# The following is the .spl_contest printout:
Browse[1]> .spl_context
    split     value full_parent_df all_cols_n      all obs
1    root      root   c("S1", ....        356 TRUE, TR....
2     ARM A: Drug X   c("S6", ....        121 TRUE, TR....
3 STRATA1         A   c("S14",....         36 TRUE, TR....
4     AGE     young   c("S14",....         36 TRUE, TR....
                        
# NOTE: make_split_fun(pre = list(drop_facet_levels)) and drop_split_levels 
#       do the same thing in this case
```
Here we can see what is the split column variable (`split`, first column) at this level of the splitting procedure. `value` is the current split value that is being dealt with. Now, for the next column, lets see the number of rows of these dataframes: `sapply(.spl_context$full_parent_df, nrow) # [1] 356 121  36  36`. Indeed, the `root` level contains the full input dataframe, while the other levels are subgroups of the full data according to the split value. `all_cols_n` shows exactly the numbers just described. `all obs` is the current filter applied to the columns. Appling this to the root data (or the row subgroup data) reveals the current facet column-wise (and row-wise if in row split). It is possible to use the same information to make complex splits also on the column space by using the full dataframe and the value splits to select the interested values. This is something we will change and simplify when it is a more apparent need.

### Extra arguments `extra_args`
This functionality is well known and used in the setting of analysis functions (xxx vignette), but we show here how this can also apply to splits.

```{r, eval=FALSE}
# rtables 6.0.2

# Lets use the tracer!!
my_tracer <- quote(if (length(spl@extra_args) > 0) browser())
trace(what = "do_split", 
      tracer = my_tracer, 
      where = asNamespace("rtables"))
custom_mean_var <- function(var) {
    function(df, labelstr, na.rm = FALSE, ...) {
        # browser()
        mean(df[[var]], na.rm = na.rm)
    }
}
DM_ageNA <- DM
DM_ageNA$AGE[1] <- NA
basic_table() %>% 
    split_rows_by("ARM") %>% 
    split_rows_by("SEX", split_fun = drop_split_levels) %>% 
    summarize_row_groups(cfun = custom_mean_var("AGE"), 
                         extra_args = list(na.rm  = TRUE), format = "xx.x", 
                         label_fstr = "label %s") %>% 
    # content_extra_args, c_extra_args are different slots!! (xxx)
    split_rows_by("STRATA1", split_fun = keep_split_levels("A")) %>% 
    analyze("AGE") %>% # check with the extra_args (xxx)
    build_table(DM_ageNA)
# You can accumulate extra_args down to other splits. It is possible this does not
#   work. Should it? That is why extra_args lives only in splits (xxx) check if it works
#   as is. Difficult to find an use case for this. Maybe it could work for the ref_group
#   info. That does not work with nesting already (fairly sure that it will break stuff).
#   Does it make sense to have more than one ref_group at any point of the analysis? No docs,
#   send a warning if users try to nest things with ref_group (that is passed around via
#   extra_args)

# As we can see that was not possible. What if we now force it a bit?
my_split_fun <- function(df, spl, .spl_context, ...) {
    spl@extra_args <- list(na.rm = TRUE)
    # does not work because do_split is not changing the object
    # the split does not do anything with it
    drop_split_levels(df, spl)
} # does not work
basic_table() %>% 
    split_rows_by("ARM") %>% 
    split_rows_by("SEX", split_fun = my_split_fun) %>% 
    analyze("AGE", inclNAs = TRUE, afun = mean) %>%  # include_NAs is set FALSE 
    build_table(DM_ageNA)
# extra_args is in available in cols but not in rows, because different columns 
#  may need it for different col space. Row-wise it seems not necessary.
#  The only thing that works is adding it to analyze (xxx) check if it is worth adding

# We invite the developer now to test all the tests file of this package with the tracer on
# therefore -> extra_args is not currently used in splits (xxx could be wrong) 
# could be not being hooked up
untrace(what = "do_split", where = asNamespace("rtables"))

# Let's try with the other variables identically
my_tracer <- quote(if (!is.null(vals) || !is.null(labels) || isTRUE(trim)) {
    print("A LOT TO SAY")
    message("CANT BLOCK US ALL")
    stop("NOW FOR SURE")
    browser()
    })
trace(what = "do_split", 
      tracer = my_tracer, 
      where = asNamespace("rtables"))
# Run tests by copying the above in setup-fakedata.R (then devtools::test())
untrace(what = "do_split", 
        where = asNamespace("rtables"))
```
As we have demonstrated, all the above seems like impossible cases, and are to be considered as vestigial and deprecated heritage.

### Final examples with `MultiVarSplit` & `CompoundSplit`
This final part of this chapter is still under construction, hence, the unspecific mentions and the to do list.
xxx `CompoundSplit` generates facets from one variable (e.g. cumulative distributions) while `MultiVarSplit` uses different variables for the split. See `AnalyzeMultiVars`, which inherits from `CompoundSplit` for more details on how it analyzes the same facets multiple times. `MultiVarColSplit` works with `analyze_colvars`, which is a different discussion. `.set_kids_sect_sep` adds things between children (can be set from split).

Firstly, we want to see how `MultiVarSplit` class behaves for an example case taken from
`?split_rows_by_multivar`.

```{r, eval=FALSE}
# rtables 6.0.2

my_tracer <- quote(if (is(spl, "MultiVarSplit")) browser())
trace(what = "do_split", 
      tracer = my_tracer, 
      where = asNamespace("rtables"))
# We want also to take a look at the following:
debugonce(rtables:::.apply_split_inner)
lyt <- basic_table() %>%
    split_cols_by("ARM") %>% 
    split_rows_by_multivar(c("BMRKR1", "BMRKR1"), 
                           varlabels = c("SD", "MEAN")) %>%
    split_rows_by("COUNTRY",
                  split_fun = keep_split_levels("PAK")) %>% # xxx for #690 #691
    summarize_row_groups() %>%
    analyze(c("AGE", "SEX")) 

build_table(lyt, DM)

# xxx check empty space on top -> check if it is a bug, file it
untrace(what = "do_split", 
        where = asNamespace("rtables"))
```

If we print them out, we will notice that the two groups (one called "SEX" and the other "STRATA1") are identical along the columns. This is because no subgroup was actually created. This is an interesting way to personalize splits and with the help of custom split functions and their split context, also to have widely different subgroups in the table.

We invite the reader to try to understand why `split_rows_by_multivar` can have other row splits under it (see `xxx` comment in the previous code), while `split_cols_by_multivar` does not. It is a known bug at the moment, and we would be pleased to have a fix. The issues are often linked in the code by their code number (e.g. `#690`).

Lastly, we will briefly show an example of a split with cut function and how to replace it and solve the problem with empty age groups we had before. In the following, we propose the same simplified situation:

```{r}
# rtables 6.0.2

cutfun <- function(x) {
  # browser()
  cutpoints <- c(0, 50, 100)

  names(cutpoints) <- c("", "Younger", "Older")
  cutpoints
}

tbl <- basic_table(show_colcounts = TRUE) %>% 
    split_rows_by("ARM", 
                  split_fun = drop_and_remove_levels(c("B: Placebo", "C: Combination"))) %>% 
    split_rows_by("STRATA1") %>% 
    split_rows_by_cutfun("AGE", cutfun = cutfun) %>%
    # split_rows_by_cuts("AGE", cuts = c(0, 50, 100),
    #               cutlabels = c("young", "old")) %>% # Works the same
    split_rows_by("SEX", split_fun = drop_split_levels) %>% 
    summarize_row_groups() %>%  # This is degenerate!!! 
    build_table(DM)

tbl
```
For both cases (`*_cuts` and `*_cutfun`), we have empty levels that are not dropped. This is to be expected and can be avoided by using a dedicated split function. Only intentionally looking at the future split is possible to know if there is any element in it. At the moment, though, it is not possible to add `spl_fun` to dedicated split function like `split_rows_by_cuts`.

Note too that in the previous table we used only `summarize_row_groups` but no `analyze`. This rendered nicely but it is not the standard way to go as `summarize_row_groups` was intended ONLY to decorate row groups, i.e. row with labels. Internally, these rows are called content rows and that is why the analysis functions here are called `cfun` instead of `afun`. Indeed, also the tabulation machinery presents these two differences as it is described here (xxx link to tabulation vignette).

We can try anyway to construct the split function for cuts manually with `make_split_fun`:
```{r, eval=FALSE}
my_count_afun <- function(x, .N_col, .spl_context, ...) {
    # browser()
    out <- list(c(length(x), length(x)/.N_col))
    names(out) <- .spl_context$value[nrow(.spl_context)] # workaround (xxx #689)
    in_rows(.list = out,
            .formats = c("xx (xx.x%)"))
}
# ?make_split_fun # To check for docs/examples

# Core split
cuts_core <- function(spl, df, vals, labels, .spl_context) {
    # browser() # file an issue xxx
    # variables that are split on are converted to factor during the original clean-up
    # cut split are not doing it but it is an exception. xxx 
    # young_v <- as.numeric(df[["AGE"]]) < 50
    # current solution:
    young_v <- as.numeric(as.character(df[["AGE"]])) < 50
    make_split_result(c("young", "old"),
                      datasplit = list(df[young_v,], df[!young_v,]),
                      labels = c("Younger", "Older"))
}
drop_empties <- function(splret, spl, fulldf, ...){
    # browser()
    nrows_data_split <- vapply(splret$datasplit, nrow, numeric(1))
    to_keep <- nrows_data_split > 0
    make_split_result(splret$values[to_keep],
                      splret$datasplit[to_keep],
                      splret$labels[to_keep])
}
gen_split <- make_split_fun(core_split = cuts_core,
                            post = list(drop_empties))

tbl <- basic_table(show_colcounts = TRUE) %>% 
    split_rows_by("ARM", split_fun = keep_split_levels(c("A: Drug X"))) %>% 
    split_rows_by("STRATA1") %>% 
    split_rows_by("AGE", split_fun = gen_split) %>%
    analyze("SEX") %>% # It is the last step!! No need of BMRKR1 right?
    # split_rows_by("SEX", split_fun = drop_split_levels, 
    #               child_labels = "hidden") %>% # close issue #689. would it work for
    # analyze_colvars? probably (xxx)
    # analyze("BMRKR1", afun = my_count_afun) %>%  # This is NOT degenerate!!! BMRKR1 is only placeholder
    build_table(DM)

tbl
```
There is another way to go. We could prune them out!
```{r}
# rtables 6.0.2

tbl <- basic_table(show_colcounts = TRUE) %>% 
    split_rows_by("ARM", split_fun = keep_split_levels(c("A: Drug X"))) %>% 
    split_rows_by("STRATA1") %>% 
    split_rows_by_cuts("AGE", cuts = c(0, 50, 100),
                  cutlabels = c("young", "old")) %>%
    split_rows_by("SEX", split_fun = drop_split_levels) %>% 
    summarize_row_groups() %>%  # This is degenerate!!! # we keep it until #689 
    build_table(DM)

tbl

# Trying with pruning
prune_table(tbl) #(xxx) what is going on here? it is degenerate so it has no real leaves
# It is degenerate -> what to do?
# The same mechanism is applied in the case of NULL leaves, they are rolled up in the 
#  table tree
```
(xxx) add the pre-proc with z-scoring
