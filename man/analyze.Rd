% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/colby_constructors.R
\name{analyze}
\alias{analyze}
\title{Generate Rows Analyzing Variables Across Columns}
\usage{
analyze(
  lyt,
  vars,
  afun = rtab_inner,
  var_labels = vars,
  format = NULL,
  nested = TRUE,
  inclNAs = FALSE,
  extra_args = list(),
  show_labels = c("default", "visible", "hidden"),
  indent_mod = 0L
)
}
\arguments{
\item{lyt}{layout object pre-data used for tabulation}

\item{vars}{character vector. Multiple variable names.}

\item{afun}{function. Analysis function, must take \code{x} or \code{df} as its first parameter. Can optionally take other parameters which will be populated by the tabulation framework. See Details in \code{\link{analyze}}.}

\item{var_labels}{character. Variable labels for 1 or more variables}

\item{format}{FormatSpec. Format associated with this split. Formats can be declared via strings (\code{"xx.x"}) or function. In cases such as \code{analyze} calls, they can character vectors or lists of functions.}

\item{nested}{boolean, Add this as a new top-level split  (defining a new subtable directly under root). Defaults to \code{FALSE}}

\item{inclNAs}{boolean. Should observations with NA in the \code{var} variable(s) be included when performing this analysis. Defaults to \code{FALSE}}

\item{extra_args}{list. Extra arguments to be passed to the tabulation function. Element position in thte list corresponds to the children of this split. Named elements in the child-specific lists are ignored if they do not match a formal argument of the ttabulation function.}

\item{indent_mod}{numeric. Modifier for the default indent position for the structure created by this function(subtable, content table, or row) \emph{and all of that structure's children}. Defaults to 0, which corresponds to the unmodified default behavior.}
}
\description{
Adding /analyzed variables/ to our table layout defines the primary tabulation to be performed. We do this by adding
calls to \code{analyze} and/or \code{\link{analyze_colvars}} into our layout pipeline. As with
adding further splitting, the tabulation will occur at the current/next level of nesting by default.
}
\details{
When non-NULL \code{format} is used to specify formats for all generated rows, and can be a character vector, a function, or a list of functions. It will be repped out to the number of rows once this is known during the tabulation process, but will be overridden by formats specified within \code{rcell} calls in \code{afun}.

The analysis function (\code{afun}) should take as its first parameter either \code{x} or \code{df}. Which of these the
function accepts changes the behavior when tabulation is performed.

\itemize{
\item{
If \code{afun}'s first parameter is x, it will receive the corresponding subset \emph{vector} of data from the
relevant column (from \code{var} here) of the raw data being used to build the table.
}

\item{
If \code{afun}'s first parameter is \code{df}, it will receive the corresponding subset \emph{data.frame} (i.e. all
columns) of the raw data being tabulated
}
}

In addition to differentiation on the first argument, the analysis function can optionally accept a number of other
parameters which, \emph{if and only if} present in the formals will be passed to the function by the tabulation
machinery. These are as follows:

\describe{
\item{.N_col}{column-wise N (column count) for the full column being tabulated within}
\item{.N_total}{overall N (all observation count, defined as sum of column counts) for the tabulation}
\item{.var}{variable that is analyzed}
\item{.ref_group}{data.frame or vector of subset corresponding to the \code{ref_group} column including subsetting
defined by row-splitting. Optional and only required/meaningful if a \code{ref_group} column has been defined}
\item{.ref_full}{data.frame or vector of subset corresponding to the \code{ref_group} column without subsetting
defined by row-splitting. Optional and only required/meaningful if a \code{ref_group} column has been defined}
\item{.in_ref_col}{boolean indicates if calculation is done for cells withing the reference column}
}
}
\examples{

l <- basic_table() \%>\%
    split_cols_by("ARM") \%>\%
    analyze("AGE", afun = list_wrap_x(summary) , format = "xx.xx")
l

build_table(l, DM)


l <- basic_table() \%>\%
    split_cols_by("Species") \%>\%
    analyze(head(names(iris), -1), afun = function(x) {
        list(
            "mean / sd" = rcell(c(mean(x), sd(x)), format = "xx.xx (xx.xx)"),
            "range" = rcell(diff(range(x)), format = "xx.xx")
        )
    })
l
build_table(l, iris)

}
\author{
Gabriel Becker
}
