% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/tree_accessors.R, R/tt_paginate.R
\name{obj_name,VNodeInfo-method}
\alias{obj_name,VNodeInfo-method}
\alias{obj_name,Split-method}
\alias{obj_name<-,VNodeInfo-method}
\alias{obj_name<-,Split-method}
\alias{obj_label,Split-method}
\alias{obj_label,TableRow-method}
\alias{obj_label,VTableTree-method}
\alias{obj_label,ValueWrapper-method}
\alias{obj_label<-,Split-method}
\alias{obj_label<-,TableRow-method}
\alias{obj_label<-,ValueWrapper-method}
\alias{obj_label<-,VTableTree-method}
\alias{obj_format,VTableNodeInfo-method}
\alias{obj_format,CellValue-method}
\alias{obj_format,Split-method}
\alias{obj_format<-,VTableNodeInfo-method}
\alias{obj_format<-,Split-method}
\alias{obj_format<-,CellValue-method}
\alias{obj_na_str,Split-method}
\alias{main_title,VTitleFooter-method}
\alias{main_title<-,VTitleFooter-method}
\alias{subtitles,VTitleFooter-method}
\alias{subtitles<-,VTitleFooter-method}
\alias{main_footer,VTitleFooter-method}
\alias{main_footer<-,VTitleFooter-method}
\alias{prov_footer,VTitleFooter-method}
\alias{prov_footer<-,VTitleFooter-method}
\alias{table_inset,VTableNodeInfo-method}
\alias{table_inset,PreDataTableLayouts-method}
\alias{table_inset<-,VTableNodeInfo-method}
\alias{table_inset<-,PreDataTableLayouts-method}
\alias{table_inset<-,InstantiatedColumnInfo-method}
\alias{formatters_methods}
\alias{nlines,TableRow-method}
\alias{nlines,LabelRow-method}
\alias{nlines,RefFootnote-method}
\alias{nlines,InstantiatedColumnInfo-method}
\alias{make_row_df,VTableTree-method}
\alias{make_row_df,TableRow-method}
\alias{make_row_df,LabelRow-method}
\title{Methods for generics in the formatters package}
\usage{
\S4method{obj_name}{VNodeInfo}(obj)

\S4method{obj_name}{Split}(obj)

\S4method{obj_name}{VNodeInfo}(obj) <- value

\S4method{obj_name}{Split}(obj) <- value

\S4method{obj_label}{Split}(obj)

\S4method{obj_label}{TableRow}(obj)

\S4method{obj_label}{VTableTree}(obj)

\S4method{obj_label}{ValueWrapper}(obj)

\S4method{obj_label}{Split}(obj) <- value

\S4method{obj_label}{TableRow}(obj) <- value

\S4method{obj_label}{ValueWrapper}(obj) <- value

\S4method{obj_label}{VTableTree}(obj) <- value

\S4method{obj_format}{VTableNodeInfo}(obj)

\S4method{obj_format}{CellValue}(obj)

\S4method{obj_format}{Split}(obj)

\S4method{obj_format}{VTableNodeInfo}(obj) <- value

\S4method{obj_format}{Split}(obj) <- value

\S4method{obj_format}{CellValue}(obj) <- value

\S4method{obj_na_str}{Split}(obj)

\S4method{main_title}{VTitleFooter}(obj)

\S4method{main_title}{VTitleFooter}(obj) <- value

\S4method{subtitles}{VTitleFooter}(obj)

\S4method{subtitles}{VTitleFooter}(obj) <- value

\S4method{main_footer}{VTitleFooter}(obj)

\S4method{main_footer}{VTitleFooter}(obj) <- value

\S4method{prov_footer}{VTitleFooter}(obj)

\S4method{prov_footer}{VTitleFooter}(obj) <- value

\S4method{table_inset}{VTableNodeInfo}(obj)

\S4method{table_inset}{PreDataTableLayouts}(obj)

\S4method{table_inset}{VTableNodeInfo}(obj) <- value

\S4method{table_inset}{PreDataTableLayouts}(obj) <- value

\S4method{table_inset}{InstantiatedColumnInfo}(obj) <- value

\S4method{nlines}{TableRow}(x, colwidths = NULL, max_width = NULL)

\S4method{nlines}{LabelRow}(x, colwidths = NULL, max_width = NULL)

\S4method{nlines}{RefFootnote}(x, colwidths = NULL, max_width = NULL)

\S4method{nlines}{InstantiatedColumnInfo}(x, colwidths = NULL, max_width = NULL)

\S4method{make_row_df}{VTableTree}(
  tt,
  colwidths = NULL,
  visible_only = TRUE,
  rownum = 0,
  indent = 0L,
  path = character(),
  incontent = FALSE,
  repr_ext = 0L,
  repr_inds = integer(),
  sibpos = NA_integer_,
  nsibs = NA_integer_,
  max_width = NULL
)

\S4method{make_row_df}{TableRow}(
  tt,
  colwidths = NULL,
  visible_only = TRUE,
  rownum = 0,
  indent = 0L,
  path = "root",
  incontent = FALSE,
  repr_ext = 0L,
  repr_inds = integer(),
  sibpos = NA_integer_,
  nsibs = NA_integer_,
  max_width = NULL
)

\S4method{make_row_df}{LabelRow}(
  tt,
  colwidths = NULL,
  visible_only = TRUE,
  rownum = 0,
  indent = 0L,
  path = "root",
  incontent = FALSE,
  repr_ext = 0L,
  repr_inds = integer(),
  sibpos = NA_integer_,
  nsibs = NA_integer_,
  max_width = NULL
)
}
\arguments{
\item{obj}{ANY. The object for the accessor to access or modify}

\item{value}{The new value}

\item{x}{An object}

\item{colwidths}{numeric vector. Column widths for use with vertical pagination.}

\item{max_width}{numeric(1). Width strings should be wrapped to
when determining how many lines they require.}

\item{tt}{TableTree (or related class). A TableTree object representing a
populated table.}

\item{visible_only}{logical(1). Should only visible aspects of the table structure be reflected in this summary.
Defaults to \code{TRUE}. May not be supported by all methods.}

\item{rownum}{numeric(1). Internal detail do not set manually.}

\item{indent}{integer(1). Internal detail do not set manually.}

\item{path}{character. A vector path for a position within the structure of a
tabletree. Each element represents a subsequent choice amongst the children
of the previous choice.}

\item{incontent}{logical(1). Internal detail do not set manually.}

\item{repr_ext}{integer(1). Internal detail do not set manually.}

\item{repr_inds}{integer. Internal detail do not set manually.}

\item{sibpos}{integer(1). Internal detail do not set manually.}

\item{nsibs}{integer(1). Internal detail do not set manually.}
}
\value{
for getters, the current value of the component being accessed
on \code{obj}, for setters, a modified copy of \code{obj} with the new value.
}
\description{
See the \code{formatters} documentation for descriptions of these generics.
}
\details{
When  \code{visible_only} is  \code{TRUE} (the  default),
methods should  return a  data.frame with  exactly one  row per
visible  row in  the table-like  object.  This  is useful  when
reasoning about  how a table  will print, but does  not reflect
the full pathing space of the structure (though the paths which
are given will all work as is).

If  supported,  when  \code{visible_only}  is  \code{FALSE},  every
structural element of the table (in row-space) will be reflected in
the  returned data.frame,  meaning the  full pathing-space  will be
represented but some rows in  the layout summary will not represent
printed rows in the table as it is displayed.

Most arguments beyond \code{tt} and \code{visible_only} are present so that
\code{make_row_df} methods can call \code{make_row_df} recursively and retain information,
and should not be set during a top-level call
}
\note{
the technically present root tree node is excluded from the summary returned dby
both \code{make_row_df} and \code{make_col_df}, as it is simply the
row/column structure of \code{tt} and thus not useful for pathing or pagination.
}
