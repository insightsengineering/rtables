% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/tt_sort.R
\name{sort_at_path}
\alias{sort_at_path}
\title{Sorting a Table at a Specific Path}
\usage{
sort_at_path(
  tt,
  path,
  scorefun,
  decreasing = NA,
  na.pos = c("omit", "last", "first"),
  .prev_path = character()
)
}
\arguments{
\item{tt}{TableTree (or related class). A TableTree object representing a
populated table.}

\item{path}{character. A vector path for a position within the structure of a
tabletree. Each element represents a subsequent choice amongst the children
of the previous choice.}

\item{scorefun}{function. Scoring function, should accept the type of
children directly under the position at \code{path} (either \code{VTableTree},
\code{VTableRow}, or \code{VTableNodeInfo}, which covers both) and return a numeric value
to be sorted.}

\item{decreasing}{logical(1). Should the the scores generated by
\code{scorefun} be sorted in decreasing order. If unset (the default of
\code{NA}), it is set to \code{TRUE} if the generated scores are numeric
and \code{FALSE} if they are characters.}

\item{na.pos}{character(1). What should be done with children (sub-trees/rows)
with \code{NA} scores. Defaults to \code{"omit"}, which removes them, other
allowed values are \code{"last"}  and \code{"first"} which indicate where
they should be placed in the order.}

\item{.prev_path}{character. Internal detail, do not set manually.}
}
\value{
A \code{TableTree} with the same structure as \code{tt} with the exception
that the requested sorting has been done at \code{path}.
}
\description{
Main sorting function to order the substructure of a \code{TableTree}
at a particular Path in the table tree.
}
\details{
The \code{path} here can include the "wildcard" \code{"*"} as a step,
which translates roughly to \emph{any} node/branching element and means
that each child at that step will be \emph{separately} sorted based on
\code{scorefun} and the remaining \code{path} entries. This can occur
multiple times in a path.

Note that sorting needs a deeper understanding of table structure in
\code{rtables}. Please consider reading related vignette
(\href{https://insightsengineering.github.io/rtables/main/articles/sorting_pruning.html}{Sorting and Pruning})
and explore table structure with useful functions like \code{\link[=table_structure]{table_structure()}}
and \code{\link[=row_paths_summary]{row_paths_summary()}}. It is also very important to understand the
difference between "content" rows and "data" rows. The first one analyzes
and describes the split variable generally and is generated with
\code{\link[=summarize_row_groups]{summarize_row_groups()}}, while the second one is commonly produced by
calling one of the various \code{\link[=analyze]{analyze()}} instances.

Built-in score functions are \code{\link[=cont_n_allcols]{cont_n_allcols()}} and \code{\link[=cont_n_onecol]{cont_n_onecol()}}.
They are both working with content rows (coming from \code{\link[=summarize_row_groups]{summarize_row_groups()}})
while a custom score function needs to be used on \code{DataRow}s. Here, some
useful decriptor and accessor functions (coming from related vignette):
\itemize{
\item \code{\link[=cell_values]{cell_values()}} - Retrieves a named list of a \code{TableRow} or
\code{TableTree} object's values.
\item \code{\link[=obj_name]{obj_name()}} - Retrieves the name of an object. Note this can differ
from the label that is displayed (if any is) when printing.
\item \code{\link[=obj_label]{obj_label()}} - Retrieves the display label of an object. Note this
can differ from the name that appears in the path.
\item \code{\link[=content_table]{content_table()}} - Retrieves a \code{TableTree} object's content table
(which contains its summary rows).
\item \code{\link[=tree_children]{tree_children()}} - Retrieves a \code{TableTree} object's direct children
(either subtables, rows or possibly a mix thereof, though that
should not happen in practice).
}
}
\examples{
# Creating a table to sort

# Function that gives two statistics per table-tree "leaf"
more_analysis_fnc <- function(x) {
  in_rows(
      "median" = median(x),
      "mean" = mean(x),
      .formats = "xx.x"
  )
}
  
# Main layout of the table
raw_lyt <- basic_table() \%>\%
    split_cols_by("ARM") \%>\%
    split_rows_by(
        "RACE",
        split_fun = drop_and_remove_levels("WHITE") # dropping WHITE levels
    ) \%>\%
    summarize_row_groups() \%>\%
    split_rows_by("STRATA1") \%>\%
    summarize_row_groups() \%>\%
    analyze("AGE", afun = more_analysis_fnc)

# Creating the table and pruning empty and NAs
tbl <- build_table(raw_lyt, DM) \%>\%
    prune_table() 

# Peek at the table structure to understand how it is built
table_structure(tbl)

#  Sorting only ASIAN sub-table, or, in other words, sorting STRATA elements for
# the ASIAN group/row-split. This uses content_table() accessor function as it
# is a "ContentRow". In this case, we also base our sorting only on the second column.
sort_at_path(tbl, c("ASIAN", "STRATA1"), cont_n_onecol(2))

# Custom scoring function that is working on "DataRow"s  
scorefun <- function(tt) {
  # Here we could use browser()
  sum(unlist(row_values(tt))) # Different accessor function
}
# Sorting mean and median for all the AGE leaves!
sort_at_path(tbl, c("RACE", "*", "STRATA1", "*", "AGE"), scorefun)

}
\seealso{
\code{\link[=cont_n_allcols]{cont_n_allcols()}} and \code{\link[=cont_n_onecol]{cont_n_onecol()}}
}
