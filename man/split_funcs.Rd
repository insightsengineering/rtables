% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/split_funs.R
\name{split_funcs}
\alias{split_funcs}
\alias{keep_split_levels}
\alias{remove_split_levels}
\alias{drop_split_levels}
\alias{drop_and_remove_levels}
\alias{reorder_split_levels}
\alias{trim_levels_in_group}
\title{Split functions}
\usage{
keep_split_levels(only, reorder = TRUE)

remove_split_levels(excl)

drop_split_levels(df, spl, vals = NULL, labels = NULL, trim = FALSE)

drop_and_remove_levels(excl)

reorder_split_levels(neworder, newlabels = neworder, drlevels = TRUE)

trim_levels_in_group(innervar, drop_outlevs = TRUE)
}
\arguments{
\item{only}{(\code{character})\cr levels to retain (all others will be dropped). If none of the levels is present
an empty table is returned.}

\item{reorder}{(\code{flag})\cr whether the order of \code{only} should be used as the order of the children of the
split. Defaults to \code{TRUE}.}

\item{excl}{(\code{character})\cr levels to be excluded (they will not be reflected in the resulting table structure
regardless of presence in the data).}

\item{df}{(\code{data.frame} or \code{tibble})\cr dataset.}

\item{spl}{(\code{Split})\cr a \code{Split} object defining a partitioning or analysis/tabulation of the data.}

\item{vals}{(\code{ANY})\cr for internal use only.}

\item{labels}{(\code{character})\cr labels to use for the remaining levels instead of the existing ones.}

\item{trim}{(\code{flag})\cr whether splits corresponding with 0 observations should be kept when tabulating.}

\item{neworder}{(\code{character})\cr new order of factor levels.}

\item{newlabels}{(\code{character})\cr labels for (new order of) factor levels.}

\item{drlevels}{(\code{flag})\cr whether levels in the data which do not appear in \code{neworder} should be dropped.
Defaults to \code{TRUE}.}

\item{innervar}{(\code{string})\cr variable whose factor levels should be trimmed (e.g. empty levels dropped)
\emph{separately within each grouping defined at this point in the structure}.}

\item{drop_outlevs}{(\code{flag})\cr whether empty levels in the variable being split on (i.e. the "outer"
variable, not \code{innervar}) should be dropped. Defaults to \code{TRUE}.}
}
\value{
A function that can be used to split the data accordingly. The actual function signature
is similar to the one you can define when creating a fully custom one. For more details see \link{custom_split_funs}.
}
\description{
Split functions
}
\section{Functions}{
\itemize{
\item \code{keep_split_levels()}: keeps only specified levels (\code{only}) in the split variable. If any of the specified
levels is not present, an error is returned. \code{reorder = TRUE} (the default) orders the split levels
according to the order of \code{only}.

\item \code{remove_split_levels()}: Removes specified levels (\code{excl}) from the split variable.

\item \code{drop_split_levels()}: Drops levels that have no representation in the data.

\item \code{drop_and_remove_levels()}: Removes specified levels \code{excl} and drops all levels that are
not in the data.

\item \code{reorder_split_levels()}: Reorders split levels following \code{neworder}, which needs to be of
same size as the levels in data.

}}
\examples{
lyt <- basic_table() \%>\%
  split_rows_by("COUNTRY",
    split_fun = keep_split_levels(c("USA", "CAN", "BRA"))
  ) \%>\%
  analyze("AGE")

tbl <- build_table(lyt, DM)
tbl

lyt <- basic_table() \%>\%
  split_rows_by("COUNTRY",
    split_fun = remove_split_levels(c(
      "USA", "CAN",
      "CHE", "BRA"
    ))
  ) \%>\%
  analyze("AGE")

tbl <- build_table(lyt, DM)
tbl

lyt <- basic_table() \%>\%
  split_rows_by("SEX", split_fun = drop_split_levels) \%>\%
  analyze("AGE")

tbl <- build_table(lyt, DM)
tbl

# Removing "M" and "U" directly, then "UNDIFFERENTIATED" because not in data
lyt <- basic_table() \%>\%
  split_rows_by("SEX", split_fun = drop_and_remove_levels(c("M", "U"))) \%>\%
  analyze("AGE")

tbl <- build_table(lyt, DM)
tbl

}
\seealso{
\link{custom_split_funs}
}
