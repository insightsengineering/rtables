---
title: "The Split Machinery"
author: "Davide Garolini"
date: '`r Sys.Date()`'
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{rtables Advanced Usage}
  %\VignetteEncoding{UTF-8}
  %\VignetteEngine{knitr::rmarkdown}
editor_options: 
  chunk_output_type: console
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

## Disclaimer

Any code or prose which appears in a version of this vignette on the `main` branch of the repository may reflect a specific state of things that can be more or less recent. This guide reflects very important pieces of the split machinery that are unlikely to change. We anyway invite the reader to think always that the current code may have drifted from the following document, and it is always the best practice to read directly the code on `main`.


# The Split Machinery

The scope of this vignette is understanding how `rtables` creates facets by splitting the incoming data into hierarchical groups that go from the root node to singular `rcell`s. The latter level, also called leaf-level, contains the final partition that is subjected to the analysis functions. More details from the user perspective can be found in relevant vignette `vignette("split_functions")` and function documentation like `?split_rows_by` and `?split_funcs`.

The following vignette will describe how the split machinery works for the row domain. Further information on how columns are defined will follow soon. 

NB: we must remind the reader that `rtables` is still under active development, and it has seen the efforts of multiple contributors across different years. Therefore, there may be legacy mechanisms and a couple of on-going transformations that could look different in the future.


## Process and Methods
(xxx reference to class vignette with this)

We invite the smart developer to use the provided examples as a way to get an "interactive" and dynamic vision of the internal algorithms, as they are routinely executed when constructing tables with `rtables`. This is achieved by using `browser()` and `debugonce()` on internal and exported functions (`rtables:::` or `rtables::`), as we will see in a moment. We invite also the continuous and autonomous exploration of the multiple `S3` and `S4` objects that constitute the complexity and power of `rtables`. To do so we will use the following useful functions:

* `methods(generic_function)`: This function lists the methods that are available for a generic function. Specifically for `S4` generic functions, `showMethods(generic_function)` is giving a more detailed information about each method (e.g. inheritance). 
* `class(object)`: This function returns the class of an object. If the class is not one of the built-in classes in R, you can use this information to search for its documentation and examples. Indeed, `help(class)` may be informative, as it will call the documentation of the specific class. Similarly, the `?` operator will call the disambiguation page that delivers you to different `S4` methods. For `S3` methods it is necessary to postfix the class name with a dot (e.g. `?summary.lm`).
* `getClass(class)`: This describes in a compact way the type of class, the slots that it has, and the relationships that it may have with the other classes that may inherit or be inherited by it. With `getClass(object)`, instead, we can see to which values the slots of the object are assigned. It is possible to use `str(object, max.level = 2)` to see a less formal and more compact descriptions of the slots, but it may be problematic when there are one or more objects in the class slots. Hence, the maximum number of level should always be limited to 2 or 3 (`max.level = 2`). Similarly, `attributes()` can be used to retrieve some information, but we need to remember that storing important variables in this way is not encouraged. Information regarding the type of class can be retrieved with `mode()` and indirectly by `summary()` and `is.S4()`.
*`getAnywhere(function)` is very useful to get the source code of internal functions and specific generics. It works very well with `S3` methods, and will in any case display for each of the found methods, its relevant namespace. Similarly, `getMethod(S4_generic, S4_class)` can retrieve the source code of `S4` methods that are specific to a class.
* `eval(debugcall(generic_function(obj)))`: this is a very useful way to browser a `S4` method defined specifically for a defined object without having to manually insert `browser()` into the code. It is also possible to do similarly with R > 3.4.0 where `debug*()` calls can have the triggering signature (class) specified. Both of these are modern and simplified wrappers of tracing function `trace()`.

We explore and analyze the split machinery now with a growing amount of complexity, always following relevant functions and methods throughout their execution. By going from basic to complex and by discussing important and special cases, we hope to be able to give you a good understanding of how the split machinery works. 

In practice, the majority of the split engine resides in the source file `R/split_funs.R` with occasional incursion into `R/make_split_fun.R` for custom split function creation and rarer references to other more general tabulation files.


## `do_split`

The split machinery is so fundamental to `rtables` that relevant functions like `do_split` are executed, even when no split is requested. The following example shows how we can enter `do_split` and start understanding the class hierarchy and the main split engine.

```{r, message=FALSE}
library(rtables)
# debugonce(rtables:::do_split) # Uncomment me to enter the function!!!
basic_table() %>%
    build_table(DM)
```

In the following, we copied it so to allow the reader to go through the general structure with its enhanced comments and sections. Each section in the code reflects roughly a section of this vignette.

```{r, eval=FALSE}
# rtables 6.0.2
### NB This is called at EACH level of recursive splitting
do_split <- function(spl,
                     df,
                     vals = NULL,
                     labels = NULL,
                     trim = FALSE,
                     spl_context) {
# CHECKS #
    ## This will error if, e.g., df does not have columns
    ##  required by spl, or generally any time the split (spl)
    ##  can not be applied to df
    check_validsplit(spl, df)
    
# SPLIT FUNCTION #
    ## In special cases, we need to partition data (split)
    ##  in a very specific way, e.g. depending on the data or 
    ##  external values. These can be achieved by using a custom
    ##  split function.
    
    ## note the <- here!!!
    if(!is.null(splfun <- split_fun(spl))) {
        ## Currently the contract is that split_functions take df, vals, labels and
        ## return list(values=., datasplit=., labels = .), optionally with
        ## an additional extras element
        if(func_takes(splfun, ".spl_context")) {
            ret <- tryCatch(splfun(df, spl, vals, labels, trim = trim,
                                   .spl_context = spl_context),
                            error = function(e) e) ## rawvalues(spl_context ))
        } else {
            ret <- tryCatch(splfun(df, spl, vals, labels, trim = trim),
                            error = function(e) e)
        }
        if(is(ret, "error")) {
            stop("Error applying custom split function: ", ret$message, "\n\tsplit: ",
                 class(spl), " (", payloadmsg(spl), ")\n",
                 "\toccured at path: ",
                 spl_context_to_disp_path(spl_context), "\n")
        }
    } else {
# .apply_split_inner #
        ## This is called when no split function is provided. Please note that also when provided,
        ##  this function will be probably called, as far as the main splitting method is not willingly
        ##  modified by the split function.
        ret <- .apply_split_inner(df = df, spl = spl, vals = vals, labels = labels, trim = trim)
    }

# EXTRA #
    ## this adds .ref_full and .in_ref_col
    if(is(spl, "VarLevWBaselineSplit"))
        ret <- .add_ref_extras(spl, df, ret)

# FIXUPVALS #
    ## this:
    ## - guarantees that ret$values contains SplitValue objects
    ## - removes the extras element since its redundant after the above
    ## - Ensures datasplit and values lists are named according to labels
    ## - ensures labels are character not factor
    ret <- .fixupvals(ret)
    
# RETURN #
    ret
}
```
We will see how input parameters are used and where. The most important ones are `spl` and `df`: the split objects and the input `data.frame`.


### Checks and Classes

We will start by looking at the first function called from `do_split`. This may give us a good overview of how the split itself is defined. This is, of course, the check-function (`check_validsplit`) that is used to verify if the split is valid for the data. In the following we will describe step-by-step the split-class hierarchy, but we invite the reader to explore this autonomously in future occasions. 

Lets then search the package for `check_validsplit`, you will find that it is defined as a generic in `R/split_funs.R`, where it is applied to the following "split" classes: `VarLevelSplit`, `MultiVarSplit`, `VAnalyzeSplit`, `CompoundSplit`, and `Split`. Another way to find this information, which is more useful for more spread out and complicated objects, is using `showMethods(check_validsplit)`. The virtual class `VAnalyzeSplit` (convention: it starts with "V") defines the main parent of analysis split which we discuss in detail in related vignette `vignette()` (xxx). From this, we can intuit that the `analyze()` calls actually mimic split objects as they create different results under a specific final split (or node). Now, notice that `check_validsplit` is also called in another location, i.e. in the main `R/tt_dotabulation.R` source file. This is again something related to making the "analyze" rows as it mainly checks for `VAnalyzeSplit` (link to tabulation dev guide xxx). We will discuss the other classes when they will appear in our examples (link to class hierarchy xxx). 

For the moment, we see with `class(spl)` (from the main `do_split` function) that we are dealing with an `AllSplit` object. By calling `showMethods(check_validsplit)` we will produce the following: 

```
# rtables 6.0.2
Function: check_validsplit (package rtables)
spl="AllSplit"
    (inherited from: spl="Split")
spl="CompoundSplit"
spl="MultiVarSplit"
spl="Split"
spl="VAnalyzeSplit"
spl="VarLevelSplit"
```
It means that each of the listed classes has a dedicated definition of `check_validsplit` that may largely differ from the others. Only the class `AllSplit` does not have its own function definition as it is inherited from the `Split` class. Therefore, we understand that `AllSplit` is a class parent of `Split`. This is one of the first definition of a virtual class in the package and it is the only one that does not present the "V" prefix. Any of these classes are defined along with their constructor in `R/00tabletrees.R`. Reading how `AllSplit` is structured can be an useful example to understand how split objects are expected to work. Please see the comments in the following:

```{r, eval=FALSE}
# rtables 6.0.2
setClass("AllSplit", contains = "Split")

AllSplit <- function(split_label = "",
                    cfun = NULL,
                    cformat = NULL,
                    cna_str = NA_character_,
                    split_format = NULL,
                    split_na_str = NA_character_,
                    split_name = NULL,
                    extra_args = list(),
                    indent_mod = 0L,
                    cindent_mod = 0L,
                    cvar = "",
                    cextra_args = list(),
                    ...) {
    if(is.null(split_name)) { # If the split has no name
        if(nzchar(split_label)) # (std is "")
            split_name <- split_label 
        else
            split_name <- "all obs" # Nor label, a standard split with all 
                                    # observations is assigned.
    }
    new("AllSplit", split_label = split_label,
        content_fun = cfun,
        content_format = cformat,
        content_na_str = cna_str,
        split_format = split_format,
        split_na_str = split_na_str,
        name = split_name,
        label_children = FALSE,
        extra_args = extra_args,
        indent_modifier = as.integer(indent_mod),
        content_indent_modifier = as.integer(cindent_mod),
        content_var = cvar,
        split_label_position = "hidden",
        content_extra_args = cextra_args,
        page_title_prefix = NA_character_,
        child_section_div = NA_character_)
}
```

We can see also print this information by calling `getClass("AllSplit")` for the general slot definition, or by calling `getClass(spl)` for having also all the values. Note that the first call will give also a lot of information about the class hierarchy. For more information regarding class hierarchy, please refer to the relevant vignette (xxx). We will discuss the majority of the slots by the end of this document. Now lets see if we can find some of the values described in the constructor in our object. To do so we will show here the more compact representation given by `str`. When there are multiple and hierarchical slots that contain objects themselves, calling `str` will be much less informative or not at all informative if the maximum level of nesting is not set (e.g. `max.level = 2`).

```{r, eval=FALSE}
# rtables 6.0.2
Browse[2]> str(spl, max.level = 2)
Formal class 'AllSplit' [package "rtables"] with 17 slots
  ..@ payload                : NULL
  ..@ name                   : chr "all obs"
  ..@ split_label            : chr ""
  ..@ split_format           : NULL
  ..@ split_na_str           : chr NA
  ..@ split_label_position   : chr "hidden"
  ..@ content_fun            : NULL
  ..@ content_format         : NULL
  ..@ content_na_str         : chr NA
  ..@ content_var            : chr ""
  ..@ label_children         : logi FALSE
  ..@ extra_args             : list()
  ..@ indent_modifier        : int 0
  ..@ content_indent_modifier: int 0
  ..@ content_extra_args     : list()
  ..@ page_title_prefix      : chr NA
  ..@ child_section_div      : chr NA
```

Details about these slots will be necessary in future examples, and we will deal with them at that time. Now, we gave you a hint of the complex class hierarchy that makes up `rtables`, and how to explore it autonomously. Lets go forward in `do_split`. In our case, being `AllSplit` inherited from `Split`, we are sure that the called function will be the following (read the comment!):

```{r, eval=FALSE}
# rtables 6.0.2
## default does nothing, add methods as they become
## required
setMethod("check_validsplit", "Split",
          function(spl, df)
    invisible(NULL))
```

### Split function and `.apply_split_inner`

Before diving into custom split functions we need to take a moment to analyze how `.apply_split_inner` works. This function is routinely called, also in the case we do have a split function. Lets see why this can be the case by entering it with `debugonce(.apply_split_inner)`. Of course, we are still browsing `do_split` in debug mode from the first example. We printed and commented it in the following:

```{r, eval=FALSE}
# rtables 6.0.2
.apply_split_inner <- function(spl, df, vals = NULL, labels = NULL, trim = FALSE) {
    # - INPUTS - #
    # In this case .applysplit_rawvals will attempt finding the split values if vals is NULL.
    # Please notice that they might be a non-mutually exclusive set or subset of elements that
    # will constitute the split.
    
    # - SPLIT VALS - # 
    ## try to calculate values first. Most of the time we can
    if(is.null(vals))
        vals <- .applysplit_rawvals(spl, df)
    
    # - EXTRA PARAMETERS - #
    # This call extracts extra parameters from the split, according to the split values
    extr <- .applysplit_extras(spl, df, vals)

    # If there are no values to do the split upon, we return an empty final split
    if(is.null(vals)) {
        return(list(values = list(),
                    datasplit = list(),
                    labels = list(),
                    extras = list()))
    }

    # - DATA SUBSETTING - #
    dpart <- .applysplit_datapart(spl, df, vals)

    # - LABEL RETRIEVAL - #
    if(is.null(labels))
        labels <- .applysplit_partlabels(spl, df, vals, labels)
    else
        stopifnot(names(labels) == names(vals))
    
    # - TRIM - #
    ## get rid of columns that would not have any
    ## observations.
    ##
    ## But only if there were any rows to start with
    ## if not we're in a manually constructed table
    ## column tree
    if(trim) {
        hasdata <- sapply(dpart, function(x) nrow(x) > 0)
        if(nrow(df) > 0 && length(dpart) > sum(hasdata)) { #some empties
            dpart <- dpart[hasdata]
            vals <- vals[hasdata]
            extr <- extr[hasdata]
            labels <- labels[hasdata]
        }
    }

    # - ORDER RESULTS - #
    # Finds relevant order depending on spl_child_order()
    if(is.null(spl_child_order(spl)) || is(spl, "AllSplit")) {
        vord <- seq_along(vals)
    } else {
        vord <- match(spl_child_order(spl),
                     vals)
        vord <- vord[!is.na(vord)]
    }


    ## FIXME: should be an S4 object, not a list
    ret <- list(values = vals[vord],
               datasplit = dpart[vord],
               labels = labels[vord],
               extras = extr[vord])
    ret
}
```

After reading `.apply_split_inner`, we see that there are some fundamental functions, defined strictly for internal use (convention: they start with ".") that are generics and depend on the kind of split in input. `R/split_funs.R` is very kind and group their generic definition at the beginning of the file. These functions are the main dispatcher for the majority of the split machinery. This is a clear example that shows how using `S4` logic helps clarity and flexibility in programming, allowing for easy extension of the program. For compactness we show also the `showMethods` result for each generic.

```{r, eval=FALSE}
# rtables 6.0.2
# Retrieves the values that will constitute the splits (facets), not necessarily a unique list.
# They could come from the data cuts for example -> it can be anything if it produces a set of strings.
setGeneric(".applysplit_rawvals", 
           function(spl, df) standardGeneric(".applysplit_rawvals"))
# Browse[2]> showMethods(.applysplit_rawvals)
# Function: .applysplit_rawvals (package rtables)
# spl="AllSplit"
# spl="ManualSplit"
# spl="MultiVarSplit"
# spl="VAnalyzeSplit"
# spl="VarLevelSplit"
# spl="VarStaticCutSplit"
# Nothing here is inherited from the virtual class Split!!!

# Contains the subset of the data (default, but these can overlap, can also NOT be mutually exclusive).
setGeneric(".applysplit_datapart",
           function(spl, df, vals) standardGeneric(".applysplit_datapart"))
# Same as .applysplit_rawvals

# Extract the extra parameter for the split
setGeneric(".applysplit_extras",
           function(spl, df, vals) standardGeneric(".applysplit_extras"))
# Browse[2]> showMethods(.applysplit_extras)
# Function: .applysplit_extras (package rtables)
# spl="AllSplit"
#     (inherited from: spl="Split")
# spl="Split"
# This means there is only a function for the virtual class Split. 
#  So all splits behaves the same!!!

# Split label retrieval and assignment if visible.
setGeneric(".applysplit_partlabels",
           function(spl, df, vals, labels) standardGeneric(".applysplit_partlabels"))
# Browse[2]> showMethods(.applysplit_partlabels)
# Function: .applysplit_partlabels (package rtables)
# spl="AllSplit"
#     (inherited from: spl="Split")
# spl="MultiVarSplit"
# spl="Split"
# spl="VarLevelSplit"

setGeneric("check_validsplit", # our friend 
           function(spl, df) standardGeneric("check_validsplit"))
# Note: check_validsplit is an internal function but it is not excluded that one
#       day it will be exported. That is way it does not have the "." prefix.

setGeneric(".applysplit_ref_vals",
          function(spl, df, vals) standardGeneric(".applysplit_ref_vals"))
# Browse[2]> showMethods(.applysplit_ref_vals)
# Function: .applysplit_ref_vals (package rtables)
# spl="Split"
# spl="VarLevWBaselineSplit"

```

Now, we know that `.applysplit_extras` is the function that will be called first because we did not specify any `vals` and it is therefore `NULL`. This is a generic function as it can be seen by `showMethod(.applysplit_extras)`. It is indeed an `S4` generics and its source code can be determined by the following:

```{r, eval=FALSE}
# rtables 6.0.2
Browse[3]> getMethod(".applysplit_rawvals", "AllSplit")
Method Definition:

function (spl, df) 
obj_name(spl)

Signatures:
        spl       
target  "AllSplit"
defined "AllSplit"

# What is obj_name -> slot in spl
Browse[3]> obj_name(spl)
[1] "all obs"

# coming from
Browse[3]> getMethod("obj_name", "Split")
Method Definition:

function (obj) 
obj@name ##### Slot that we could see from str(spl, max.level = 2)

Signatures:
        obj    
target  "Split"
defined "Split"
```

Then we have `.applysplit_extras` that will be covered in later sections and simply extracts the extra arguments from the split objects and assign them to their relative split values. If no split values are still available, the function will exit here with an empty split. Otherwise the data will be divided in different splits or data subsets (facets) with `.applysplit_datapart`. In our current example the resulting list comprises the whole input data set (i.e. do `getMethod(".applysplit_datapart", "AllSplit")` and a list will be evident: `function (spl, df, vals) list(df)`).

Next, split labels are checked. If they are not present split values (`vals`) will be used with `.applysplit_partlabels` that, in the case of it being applied to a `Split` object, it translates into `as.character(vals)`. Otherwise, the inserted labels are checked against the name of split values.

Lastly, the split values are ordered on the basis of `spl_child_order`. In our case, which concerns the general `AllSplit`, the sorting will not happen, i.e. it will be simply dependent on the number of split values `seq_along(vals)`.

#### A simple split

In the following, we demonstrate how row splits work according to the features that we have already described. We add two splits and see how `do_split` behavior changes. Note that if we do not add an `analyze` call, the split will behave as before, giving an empty table with all observations. As default, calling `analyze` on a variable will produce a mean for each data subset that has been generated by the splits. We want to go beyond the first call of `do_split` that is by design on all observation with the purpose of generating the root split that contains all data and all the splits (indeed `AllSplit`). To achieve this goal we can use `debug(rtables:::do_split)` instead of `debugonce(rtables:::do_split)` as we will need to step in each of the splits. Alternatively, it is possible to use the more powerful `trace` function to enter specifically in the case the input is from a specific class. To do so the following can be used: `trace("do_split", quote(if(!is(spl, "AllSplit")) browser()), where = asNamespace("rtables"))`. Note that we had to specify the namespace with where. Multiple tracer elements can be added with `expression(E1, E2)` which is the same as `c(quote(E1), quote(E2))`. Specific steps can be specified with the `at` parameter. Remember to do `untrace("do_split", quote(if(!is(spl, "AllSplit")) browser()), where = asNamespace("rtables"))` to remove it.

```{r, message=FALSE}
# rtables 6.0.2
library(rtables)
library(dplyr)

# This filter is added to avoid having too many calls to do_split
DM_tmp <- DM %>% 
    filter(ARM %in% names(table(DM$ARM)[1:2])) %>% # limit to two
    filter(SEX %in% c("M", "F")) %>% # limit to two
    mutate(SEX = factor(SEX), ARM = factor(ARM)) # to drop unattended levels

# debug(rtables:::do_split)
lyt <- basic_table() %>%
    split_rows_by("ARM") %>% 
    split_rows_by("SEX") %>% 
    analyze("BMRKR1") # analyze() is needed for the table to have non-label rows

lyt %>% 
    build_table(DM_tmp)
# undebug(rtables:::do_split)
```

Now, we might want to check the formal class of `spl` before anything else.

```{r, eval=FALSE}
# rtables 6.0.2
Browse[2]> str(spl, max.level = 2)
Formal class 'VarLevelSplit' [package "rtables"] with 20 slots
  ..@ value_label_var        : chr "ARM"
  ..@ value_order            : chr [1:2] "A: Drug X" "B: Placebo"
  ..@ split_fun              : NULL
  ..@ payload                : chr "ARM"
  ..@ name                   : chr "ARM"
  ..@ split_label            : chr "ARM"
  ..@ split_format           : NULL
  ..@ split_na_str           : chr NA
  ..@ split_label_position   : chr "hidden"
  ..@ content_fun            : NULL
  ..@ content_format         : NULL
  ..@ content_na_str         : chr NA
  ..@ content_var            : chr ""
  ..@ label_children         : logi NA
  ..@ extra_args             : list()
  ..@ indent_modifier        : int 0
  ..@ content_indent_modifier: int 0
  ..@ content_extra_args     : list()
  ..@ page_title_prefix      : chr NA
  ..@ child_section_div      : chr NA
```

From this, we can directly infer that the class is different now (`VarLevelSplit`) and understand that the split label will be hidden (`split_label_position` slot). Moreover, we see a specific value order with specific split values. Also, `VarLevelSplit` seems to have three more slots than `AllSplit`. What are they precisely?

```{r, eval=FALSE}
# rtables 6.0.2
slots_as <- getSlots("AllSplit") # inherits virtual class Split and is general class for all splits
# getClass("CustomizableSplit") # -> Extends: "Split", Known Subclasses: Class "VarLevelSplit", directly
slots_cs <- getSlots("CustomizableSplit") # Adds split function
slots_vls <- getSlots("VarLevelSplit")

slots_cs[!(names(slots_cs) %in% names(slots_as))]
#        split_fun 
# "functionOrNULL" 
slots_vls[!(names(slots_vls) %in% names(slots_cs))]
# value_label_var     value_order 
#     "character"           "ANY"
```

Remember always to check the constructor and class definition inside `R/00tabletrees.R` if exploratory tools do not suffice. Now, `check_validsplit(spl, df)` will dispatch to a different method than before (`getMethod("check_validsplit", "VarLevelSplit")`). Indeed, it uses the internal utility function `.checkvarsok` to check if the `vars`, i.e. the `payload` is actually present in `names(df)`.

Now, the next relevant function will be `.apply_split_inner` where we want to see exactly what changes (`debugonce(.apply_split_inner)`). Of course, this function is directly called as no custom split function is provided. Being parameter `vals` not specified (`NULL`), the split values are retrieved from `df` by using the split payload to select specific columns (`varvec <- df[[spl_payload(spl)]]`). Every time no split values are specified, they will be retrieved from the selected column as unique values, if character, or levels, if factor. 

Next, `.applysplit_datapart` creates a named list of facets or data subsets. In this case, the result is actually a mutually exclusive partition of the data. This is because we did not specify any split values and the column content was used as such with unique call in case of a character vector or levels in case of factors. `.applysplit_partlabels` is a bit less linear as it has to take into account the possibility of having specified labels in the payload. Beside looking at the function source code with `getMethod(".applysplit_partlabels", "VarLevelSplit")`, we can enter in debugging mode the `S4` generic function as follows:

```{r, eval=FALSE}
# rtables 6.0.2
eval(debugcall(.applysplit_partlabels(spl, df, vals, labels)))
# We leave to the smart developer to see how the labels are assigned

# PS: remember to undebugcall() similarly
```

In our case, the final labels are `vals` because they were not assigned. Their order is retrieved from the split object (`spl_child_order(spl)`) and matched with current split values. The returned list is then processed as it was before.

If we continue with the next call of `do_split`, the same procedure is accomplished for the second `ARM` split. This is done on the partition that was already done in the first split. The only give out of this is the fact that the main `df` is constituted by a subset (facet) of the total data, according to the first split. This will be done iteratively for as many data split as requested. Before concluding this iteration, we take a moment to talk a bit more in detail about how `.fixupvals(partinfo)` works. It is not a generic function and the source code can be easily accessed as follows. We suggest to run through it with `debugonce(.fixupvals)` to understand what it does in practice. The fundamental aspects are listed in the following:

* Ensures that labels are character and not factor.
* Ensures that the splits of data and list of values are named according to labels.
* Guarantees that `ret$values` contains `SplitValue` objects.
* Removes the list element `extra` since its now included in the `SplitValue`.

Note that this function can occasionally be called more than once on the same return object (a named list for now). Of course, after the first call only checks are applied.

```{r, eval=FALSE}
# rtables 6.0.2
   
# Can find the following core function:
# vals <- make_splvalue_vec(vals, extr, labels = labels)
# ---> Main list of SplitValue objects: iterative call of 
#      new("SplitValue", value = val, extra = extr, label = label)

# Structure of ret before the function call
Browse[2]> str(ret, max.level = 2)
List of 4
 $ values   : chr [1:2] "A: Drug X" "B: Placebo"
 $ datasplit:List of 2
  ..$ A: Drug X : tibble [121 × 8] (S3: tbl_df/tbl/data.frame)
  ..$ B: Placebo: tibble [106 × 8] (S3: tbl_df/tbl/data.frame)
 $ labels   : Named chr [1:2] "A: Drug X" "B: Placebo"
  ..- attr(*, "names")= chr [1:2] "A: Drug X" "B: Placebo"
 $ extras   :List of 2
  ..$ : list()
  ..$ : list()
  
# Structure of ret after the function call
Browse[2]> str(.fixupvals(ret), max.level = 2)
List of 3
 $ values   :List of 2
  ..$ A: Drug X :Formal class 'SplitValue' [package "rtables"] with 3 slots
  ..$ B: Placebo:Formal class 'SplitValue' [package "rtables"] with 3 slots
 $ datasplit:List of 2
  ..$ A: Drug X : tibble [121 × 8] (S3: tbl_df/tbl/data.frame)
  ..$ B: Placebo: tibble [106 × 8] (S3: tbl_df/tbl/data.frame)
 $ labels   : Named chr [1:2] "A: Drug X" "B: Placebo"
  ..- attr(*, "names")= chr [1:2] "A: Drug X" "B: Placebo"
 
# The SplitValue object is fundamental
Browse[2]> str(ret$values)
List of 2
 $ A: Drug X :Formal class 'SplitValue' [package "rtables"] with 3 slots
  .. ..@ extra: list()
  .. ..@ value: chr "A: Drug X"
  .. ..@ label: chr "A: Drug X"
 $ B: Placebo:Formal class 'SplitValue' [package "rtables"] with 3 slots
  .. ..@ extra: list()
  .. ..@ value: chr "B: Placebo"
  .. ..@ label: chr "B: Placebo"
```


#### Included split functions

We start with a custom split function that is already defined in `rtables`. Its scope is filtering out specific values as follows:

```{r, message=FALSE}
library(rtables)
# debug(rtables:::do_split) # uncomment to see into the main split function
basic_table() %>%
    split_rows_by("SEX", split_fun = drop_split_levels) %>% 
    analyze("BMRKR1") %>%
    build_table(DM)
# undebug(rtables:::do_split)

# PS: this produces the same output as before with the filters
```

After skipping the root split, we enter the split based on column `SEX`. As we specified a split function, we retrieve the split function by using `splfun <- split_fun(spl)` and enter an `if-else` statement for the two possible cases where there is split contenxt or not. In both cases, an error catching framework is used so to give informative errors in case of failure. Later we will see better how it works.

Here, we invite to always keep a keen eye on `spl_context`, as it is fundamental for more sophisticate splits, e.g. in the cases where the split itself depends mainly on preceding splits or values. Please, when the split function is called, take a moment to look at how `drop_split_levels` is defined. You will see that it is fundamentally a wrapper of `.apply_split_inner` that drops empty factor levels, therefore avoiding empty split.

```{r, eval=FALSE}
# rtables 6.0.2
> drop_split_levels
function(df,
         spl,
         vals = NULL,
         labels = NULL,
         trim = FALSE) {
    # Retrieve split column
    var <- spl_payload(spl)
    df2 <- df
    
    ## This call is exactly the one we did in the filtering to get rid of empty levels
    df2[[var]] <- factor(df[[var]])
    
    ## Our main function!
    .apply_split_inner(spl, df2, vals = vals,
                       labels = labels,
                       trim = trim)
}
```

There are many split functions already included in `rtables`. Lists of them can be found in `vignette("split_functions")`, `?split_funcs`, and `vignette("advanced_usage")`. We leave to the smart developer finding in detail how some of these work, in particular `trim_levels_to_map`.

#### Custom split functions

Now we try to create our custom split function. Firstly, we will see how the system manages error messages. For a general understanding of how we can provide custom split functions, please read `?custom_split_funs` in detail. In the following we use browser() to enter our custom split functions. For the error cases, we invite the reader to activate `options(error = recover)` so to investigate the cases where we have an error. Note that you can retrieve original behavior by restarting `R` session or by caching the default option value. Another smart possibility is to use `callr` to retrieve the default as follows: `default_opts <- callr::r(function(){options()}); options(error = default_opts$error)`.

```{r}
# rtables 6.0.2
# Table call with only function changing
simple_table <- function(DM, f){
    lyt <- basic_table() %>% 
        split_rows_by("ARM", split_fun = f) %>% 
        analyze("BMRKR1")
    
    lyt %>% 
        build_table(DM)
}
# First round will fail because there are unused arguments
exploratory_split_fun <- function(df, spl) NULL
# debug(rtables:::do_split)
err_msg <- tryCatch(simple_table(DM, exploratory_split_fun), error = function(e) e)
# undebug(rtables:::do_split)

message(err_msg$message)
```

Commented debugging options can get you above and before the error. Nonetheless using the recover option will get you the possibility to select the frame number, i.e. the trace level to enter as debugging selecting the last one (10 in my case), will allow you to see the value of `ret` from `rtables:::do_split` that is the simple error and how the informative error message that follows is created.

```{r, eval=FALSE}
# rtables 6.0.2
# Debugging level
10: tt_dotabulation.R#627: do_split(spl, df, spl_context = spl_context)

# Original call and final error
> simple_table(DM, exploratory_split_fun)
Error in do_split(spl, df, spl_context = spl_context) : 
  Error applying custom split function: unused arguments (vals, labels, trim = trim) # This is main error
	split: VarLevelSplit (ARM) # Split reference
	occured at path: root # Path level (where it happened)
```

The previous split function fails because not all arguments are present. A simple way to avoid this is to add `...` to the function call. Now lets construct an interesting split function (and error):

```{r}
# rtables 6.0.2
f_brakes_if <- function(split_col = NULL, error = FALSE){
    function(df, spl, ...){ # order matters! more than naming
        # browser() # To check how it works
        if (is.null(split_col)) { # Retrieves the default
            split_col <- spl_variable(spl) # Internal accessor to split obj
        }
        my_payload <- split_col # Changing split column value
        
        vals <- levels(df[[my_payload]]) # Extracting values to split
        datasplit <- lapply(seq_along(vals), function(i) {
            df[df[[my_payload]] == vals[[i]], ]
        })
        names(datasplit) <- as.character(vals)
        
        # Fantasy error
        if (isTRUE(error)) {
            # browser() # If you need to check how it works
            mystery_error_values <- sapply(datasplit, function(x) mean(x$BMRKR1))
            if (any(mystery_error_values > 6)) {
                stop("It should not be more than 6! Should it be? Found in split values: ",
                     names(datasplit)[which(mystery_error_values > 6)])
            }
        }
        
        # Handy function to return a split result!!
        make_split_result(vals, datasplit, vals)
    }
}
simple_table(DM, f_brakes_if()) # works!
simple_table(DM, f_brakes_if(split_col = "STRATA1")) # works!

# Does not work, but in an informative way
# simple_table(DM, f_brakes_if(error = TRUE))

# Error in do_split(spl, df, spl_context = spl_context) :
# Error applying custom split function: It should not be more than 6! Should it be? Found in split values: B: Placebo
# split: VarLevelSplit (ARM)
# occured at path: root
```

Now we will dwell a moment to the relatively new machinery to create custom split functions. Before doing so, please read the relevant documentation `?make_split_fun`. The majority of functions already included in `rtables` can be or will be written with `make_split_fun` as it is a more stable constructor for such functions. We invite the reader to take a look at `make_split_fun.R`. The majority of functions should be very understandable as far as you got into this guide. We want to highlight that if no core split function is specified, which is commonly the case, `make_split_fun` calls directly `do_base_split` which is a minimal wrapper of our well known `do_split`. `drop_facet_levels` for example is a pre-processing function that at the core simply removes empty factor levels from the split "column", thus avoiding empty lines to be shown. 

It is possible, also to add a list of functions, as it can be seen in the examples of `?make_split_fun`. Note that pre and post processing need a list in input to support the possibility to combine multiple functions. The core splitting function, instead, must be a single function call as it is not expected to have stacked features. This needs rarely to be modified and the majority of the included split functions work with pre or post processing. Included post-processing functions are interesting as they interact with the split object, e.g. by reordering the facets or by adding an overall facet (`add_overall_facet`). The smart reader will have noticed as the core function rely somehow on `do_split` and many of the post processing functions rely on `make_split_result` which is the best way to get the correct split return structure. Note that modifying the core split works only in the row space at the moment.

#### `.spl_context` - a bit of context to our splits
The best way to understand what split context does and how to use it is to read relevant vignette (xxx advanced usage), and to use `browser()` a split function to see how it is structured. As `.spl_context` is needed for rewriting core functions, we propose here a wrapper of `do_base_split`, which is a handy redirection to the standard `do_split` without
the split function part, i.e. it is a wrapper of `.apply_split_inner`, the real core splitting machinery. For curiosity we set here `trim = TRUE`. This trimming works only when there is a mixed table (some values are 0s and some have content, there it trims the 0s). This is rarely the case and we encourage using the replacement functions `trim_levels_to_group` and `trim_levels_to_map`. Nowadays, it should even be impossible to set it differently from `trim = FALSE`.

(write an issue informative error for not list xxx).
```{r, eval=FALSE}
# rtables 6.0.2
browsing_f <- function(df, spl, .spl_context, ...) {
    # browser()
    # do_base_split(df, spl, ...) # order matters!! This would fail if done
    do_base_split(spl = spl, df = df, vals = NULL, labels = NULL, trim = TRUE)
}

basic_table() %>% 
    split_rows_by("ARM") %>% 
    split_rows_by("STRATA1") %>% 
    split_rows_by_cuts("AGE", cuts = c(0, 50, 100),
                  cutlabels = c("young", "old")) %>% 
    split_rows_by("SEX", split_fun = make_split_fun(
        pre = list(drop_facet_levels), # This is dropping the sex levels (age is upper level) add issue for this -> split_rows_by() wrapper with spl_fun
        core_split = browsing_f#, #(xxx why does this fail?)
        post = list(trim_levels_in_facets("AGE")) #(xxx why too fails? how to trim the empty levels?)
    )) %>% 
    summarize_row_groups() %>% 
    build_table(DM)

# The following is the .spl_contest printout:
Browse[1]> .spl_context
    split     value full_parent_df all_cols_n      all obs
1    root      root   c("S1", ....        356 TRUE, TR....
2     ARM A: Drug X   c("S6", ....        121 TRUE, TR....
3 STRATA1         A   c("S14",....         36 TRUE, TR....
4     AGE     young   c("S14",....         36 TRUE, TR....
                        
# NOTE: make_split_fun(pre = list(drop_facet_levels)) and drop_split_levels 
#       do the same in this case
```
Here we can see what is the split column variable (`split`, first column) at this level of the splitting procedure. `value` is the current split value that is being dealt with. Now, for the next column, lets see the number of rows of these dataframes: `sapply(.spl_context$full_parent_df, nrow) # [1] 356 121  36  36`. Indeed, the `root` level contains the full input dataframe, while the other levels are subgroups of the full data according to the split value. `all_cols_n` shows exactly the numbers just described. `all obs` (xxx is the column "filter" name). It is possible to use the same information to make complex splits also on the column space by using the full dataframe and the value splits to select the interested values. This is something we will fix when it will be a more apparent need.

### Extra arguments `extra_args`
This functionality is well known and used in the setting of analysis functions (xxx vignette), but we show here how this can also apply to splits.
(xxx intent is to set them on the parent and then used in the analyze call - possible this does not work. Issue to investigate this and if we need it xxx)

```{r, eval=FALSE}
# rtables 6.0.2

# Lets use the tracer!!
my_tracer <- quote(if (!is(spl, "AllSplit") && 
                       spl_variable(spl) == "SEX") browser())
trace(what = "do_split", 
      tracer = my_tracer, 
      where = asNamespace("rtables"))

basic_table() %>% 
    split_rows_by("ARM") %>% 
    split_rows_by("SEX", split_fun = drop_split_levels) %>% 
    summarize_row_groups(extra_args = list(a  = 3)) %>% 
    build_table(DM)

untrace(what = "do_split", 
        where = asNamespace("rtables"))
```


### (xxx - the other parameters... trim?? Maybe it does not work, vestigial)
(xxx use trace to find if vals and labels are used)

```{r, eval=FALSE}
my_tracer <- quote(if (!isTRUE(trim)) browser())
trace(what = "do_split", 
      tracer = my_tracer, 
      where = asNamespace("rtables"))

wrapper_do_split <- function(){
    do_base_split(spl, df, vals = NULL, labels = NULL, trim = TRUE)
}
basic_table() %>% 
    split_rows_by("ARM") %>% 
    split_rows_by("SEX") %>% 
    analyze("BMRKR1") %>% 
    build_table(DM)
untrace(what = "do_split", 
        where = asNamespace("rtables"))
```

Final examples with `MultiVarSplit` & `CompoundSplit`

