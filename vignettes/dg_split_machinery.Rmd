---
title: "The Split Machinery"
author: "Davide Garolini"
date: '`r Sys.Date()`'
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{rtables Advanced Usage}
  %\VignetteEncoding{UTF-8}
  %\VignetteEngine{knitr::rmarkdown}
editor_options: 
  chunk_output_type: console
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```
## Disclaimer

This vignette is currently under development. Any code or prose which
appears in a version of this vignette on the `main` branch of the
repository will work/be correct, but they likely are not in their
final form.


# The Split Machinery

The scope of this vignette is understanding how `rtables` creates facets by splitting the incoming data into hierarchical groups that go from the root node to singular `rcell`s. The latter level, also called leaf-level, contains the final partition that is subjected to the analysis functions. More details from the user perspective can be found in relevant vignette `vignette("split_functions")` and function documentation like `?split_rows_by` and `?split_funcs`.

The following vignette will describe how the split machinery works for the row domain. Further information on how columns are defined will follow soon. 

NB: we must remind the reader that `rtables` is still under active development, and it has seen the efforts of multiple contributors across different years. Therefore, there may be legacy mechanisms and a couple of on-going transformations that could look different in the future.


## Process and Methods

We invite the smart developer to use the provided examples as a way to get an "interactive" and dynamic vision of the internal algorithms, as they are routinely executed when constructing tables with `rtables`. This is achieved by using `browser()` and `debugonce()` on internal and exported functions (`rtables:::` or `rtables::`), as we will see in a moment. We invite also the continuous and autonomous exploration of the multiple `S3` and `S4` objects that constitute the complexity and power of `rtables`. To do so we will use the following useful functions:

* `methods(generic.function)`: This function lists the methods that are available for a generic function. For `S4` generic functions, `showMethods(generic.function)` is giving a more detailed information about each method (e.g. inheritance).
* `class(object)`: This function returns the class of an object. If the class is not one of the built-in classes in R, you can use this information to search for its documentation and examples. Also `help(class)` calls may be informative here, as it will call the documentation of the specific class.
* `getClass(class)`: This describes in a compact way the type of class, the slots that it has, and the relationships that it may have with the other classes that may inherit or be inherited by it. With `getClass(object)`, instead, we can see to which values the slots of the object are assigned. It is possible to use `str(object, max.level = 2)` to see a less formal and more compact descriptions of the slots, but it may be problematic when there are one or more objects in the class slots. Hence, the maximum number of level should always be limited to 2 or 3 (`max.level = 2`). Similarly, `attributes()` can be used to retrieve some information, but we need to remember that storing important variables in this way is not encouraged. Information regarding the type of class can be retrieved with `mode()` and indirectly by `summary()` and `is.S4()`.

We explore and analyze the split machinery now with a growing amount of complexity, always following relevant functions and methods throughout their execution. By going from basic to complex and by discussing important and special cases, we hope to be able to give you a good understanding of how the split machinery works. 

In practice, the majority of the split engine resides in the source file `R/split_funs.R` with occasional incursion into `R/make_split_fun.R` for custom split function creation and rarer references to other more general tabulation files.


## `do_split`

The split machinery is so fundamental to `rtables` that relevant functions like `do_split` are executed, even when no split is requested. The following example shows how we can enter `do_split` and start understanding the class hierarchy and the main split engine.

```{r, message=FALSE}
## utility fnc xxx
library(rtables)
# debugonce(rtables:::do_split) # Uncomment me to enter the function!!!
basic_table() %>% 
    build_table(DM)
```

In the following, we copied it so to allow the reader to go through the general structure with its enhanced comments and sections. Each section in the code reflects roughly a section of this vignette.

```{r, eval=FALSE}
### NB This is called at EACH level of recursive splitting
do_split <- function(spl,
                     df,
                     vals = NULL,
                     labels = NULL,
                     trim = FALSE,
                     spl_context) {
# CHECKS #
    ## This will error if, e.g., df does not have columns
    ##  required by spl, or generally any time the split (spl)
    ##  can not be applied to df
    check_validsplit(spl, df)
    
# SPLIT FUNCTION #
    ## In special cases, we need to partition data (split)
    ##  in a very specific way, e.g. depending on the data or 
    ##  external values. These can be achieved by using a custom
    ##  split function.
    
    ## note the <- here!!!
    if(!is.null(splfun <- split_fun(spl))) {
        ## Currently the contract is that split_functions take df, vals, labels and
        ## return list(values=., datasplit=., labels = .), optionally with
        ## an additional extras element
        if(func_takes(splfun, ".spl_context")) {
            ret <- tryCatch(splfun(df, spl, vals, labels, trim = trim,
                                   .spl_context = spl_context),
                            error = function(e) e) ## rawvalues(spl_context ))
        } else {
            ret <- tryCatch(splfun(df, spl, vals, labels, trim = trim),
                            error = function(e) e)
        }
        if(is(ret, "error")) {
            stop("Error applying custom split function: ", ret$message, "\n\tsplit: ",
                 class(spl), " (", payloadmsg(spl), ")\n",
                 "\toccured at path: ",
                 spl_context_to_disp_path(spl_context), "\n")
        }
    } else {
# .apply_split_inner #
        ## This is called when no split function is provided. Please note that also when provided,
        ##  this function will be probably called, as far as the main splitting method is not willingly
        ##  modified by the split function.
        ret <- .apply_split_inner(df = df, spl = spl, vals = vals, labels = labels, trim = trim)
    }

# EXTRA #
    ## this adds .ref_full and .in_ref_col
    if(is(spl, "VarLevWBaselineSplit"))
        ret <- .add_ref_extras(spl, df, ret)

# FIXUPVALS #
    ## this:
    ## - guarantees that ret$values contains SplitValue objects
    ## - removes the extras element since its redundant after the above
    ## - Ensures datasplit and values lists are named according to labels
    ## - ensures labels are character not factor
    ret <- .fixupvals(ret)
    
# RETURN #
    ret
}
```
We will see how input parameters are used and where. The most important ones are `spl` and `df`; the split objects and the input `data.frame`.


### Checks and Classes

We will start by looking at the first function called from `do_split`. This may give us a good overview of how the split itself is defined. This is, of course, the check-function (`check_validsplit`) that is used to verify if the split is valid for the data. In the following we will describe step-by-step the split-class hierarchy, but we invite the reader to explore this autonomously in future occasions. 

Lets then search the package for `check_validsplit`, you will find that it is defined as a generic in `R/split_funs.R`, where it is applied to the following "split" classes: `VarLevelSplit`, `MultiVarSplit`, `VAnalyzeSplit`, `CompoundSplit`, and `Split`. Another way to find this information, which is more useful for more spread out and complicated objects, is using `showMethods(check_validsplit)`. The virtual class `VAnalyzeSplit` (convention: it starts with "V") defines the main parent of analysis split which we discuss in detail in related vignette `vignette()` (xxx). From this, we can intuit that the `analyze()` calls actually mimic split objects as they create different results under a specific final split (or node). Now, notice that `check_validsplit` is also called in another location, i.e. in the main `R/tt_dotabulation.R` source file. This is again something related to making the "analyze" rows as it mainly checks for `VAnalyzeSplit` (link to tabulation dev guide xxx). We will discuss the other classes when they will appear in our examples (link to class hierarchy xxx). 

For the moment, we see with `class(spl)` (from the main `do_split` function) that we are dealing with an `AllSplit` object. By calling `showMethods(check_validsplit)` we will produce the following: 

```
Function: check_validsplit (package rtables)
spl="AllSplit"
    (inherited from: spl="Split")
spl="CompoundSplit"
spl="MultiVarSplit"
spl="Split"
spl="VAnalyzeSplit"
spl="VarLevelSplit"
```
It means that each of the listed classes has a dedicated definition of `check_validsplit` that may largely differ from the others. Only the class `AllSplit` does not have its own function definition as it is inherited from the `Split` class. Therefore, we understand that `AllSplit` is a class parent of `Split`. This is one of the first definition of a virtual class in the package and it is the only one that does not present the "V" prefix. Any of these classes are defined along with their constructor in `R/00tabletrees.R`. Reading how `AllSplit` is structured can be an useful example to understand how split objects are expected to work. Please see the comments in the following:

```{r, eval=FALSE}
setClass("AllSplit", contains = "Split")

AllSplit <- function(split_label = "",
                    cfun = NULL,
                    cformat = NULL,
                    cna_str = NA_character_,
                    split_format = NULL,
                    split_na_str = NA_character_,
                    split_name = NULL,
                    extra_args = list(),
                    indent_mod = 0L,
                    cindent_mod = 0L,
                    cvar = "",
                    cextra_args = list(),
                    ...) {
    if(is.null(split_name)) { # If the split has no name
        if(nzchar(split_label)) # (std is "")
            split_name <- split_label 
        else
            split_name <- "all obs" # Nor label, a standard split with all 
                                    # observations is assigned.
    }
    new("AllSplit", split_label = split_label,
        content_fun = cfun,
        content_format = cformat,
        content_na_str = cna_str,
        split_format = split_format,
        split_na_str = split_na_str,
        name = split_name,
        label_children = FALSE,
        extra_args = extra_args,
        indent_modifier = as.integer(indent_mod),
        content_indent_modifier = as.integer(cindent_mod),
        content_var = cvar,
        split_label_position = "hidden",
        content_extra_args = cextra_args,
        page_title_prefix = NA_character_,
        child_section_div = NA_character_)
}
```

We can see also print this information by calling `getClass("AllSplit")` for the general slot definition, or by calling `getClass(spl)` for having also all the values. Note that the first call will give also a lot of information about the class hierarchy. We will discuss the majority of these by the end of this document. Now lets see if we can find some of the values described in the constructor in our object. To do so we will show here the more compact representation given by `str`. When there are multiple and hierarchical slots that contain objects themselves, calling `str` will be much less informative.

```{r, eval=FALSE}
Browse[2]> str(spl, max.level = 2)
Formal class 'AllSplit' [package "rtables"] with 17 slots
  ..@ payload                : NULL
  ..@ name                   : chr "all obs"
  ..@ split_label            : chr ""
  ..@ split_format           : NULL
  ..@ split_na_str           : chr NA
  ..@ split_label_position   : chr "hidden"
  ..@ content_fun            : NULL
  ..@ content_format         : NULL
  ..@ content_na_str         : chr NA
  ..@ content_var            : chr ""
  ..@ label_children         : logi FALSE
  ..@ extra_args             : list()
  ..@ indent_modifier        : int 0
  ..@ content_indent_modifier: int 0
  ..@ content_extra_args     : list()
  ..@ page_title_prefix      : chr NA
  ..@ child_section_div      : chr NA
```

Detail about these slots will be necessary in future examples, and we will deal with them at that time. Now, we gave you a hint of the complex class hierarchy that makes up `rtables`, and how to explore it autonomously. Lets go forward in `do_split`. In our case, being `AllSplit` inherited from `Split`, we are sure that the called function will be the following (read the comment!):

```{r, eval=FALSE}
## default does nothing, add methods as they become
## required
setMethod("check_validsplit", "Split",
          function(spl, df)
    invisible(NULL))
```

### Split function and `.apply_split_inner`

Before diving into custom split functions we need to take a moment to analyze how `.apply_split_inner` works. This function is routinely called, also in the case we do have a split function. Lets see why this can be the case by entering it with `debugonce(.apply_split_inner)`. Of course, we are still browsing `do_split` in debug mode from the first example. We printed and commented it in the following:

```{r, eval=FALSE}
.apply_split_inner <- function(spl, df, vals = NULL, labels = NULL, trim = FALSE) {

    ## try to calculate values first. Most of the time we can
    if(is.null(vals))
        vals <- .applysplit_rawvals(spl, df)
    extr <- .applysplit_extras(spl, df, vals)

    if(is.null(vals)) {
        return(list(values = list(),
                    datasplit = list(),
                    labels = list(),
                    extras = list()))
    }

    dpart <- .applysplit_datapart(spl, df, vals)

    if(is.null(labels))
        labels <- .applysplit_partlabels(spl, df, vals, labels)
    else
        stopifnot(names(labels) == names(vals))
    ## get rid of columns that would not have any
    ## observations.
    ##
    ## But only if there were any rows to start with
    ## if not we're in a manually constructed table
    ## column tree
    if(trim) {
        hasdata <- sapply(dpart, function(x) nrow(x) > 0)
        if(nrow(df) > 0 && length(dpart) > sum(hasdata)) { #some empties
            dpart <- dpart[hasdata]
            vals <- vals[hasdata]
            extr <- extr[hasdata]
            labels <- labels[hasdata]
        }
    }

    if(is.null(spl_child_order(spl)) || is(spl, "AllSplit")) {
        vord <- seq_along(vals)
    } else {
        vord <- match(spl_child_order(spl),
                     vals)
        vord <- vord[!is.na(vord)]
    }


    ## FIXME: should be an S4 object, not a list
    ret <- list(values = vals[vord],
               datasplit = dpart[vord],
               labels = labels[vord],
               extras = extr[vord])
    ret
}
```

After reading `.apply_split_inner`, we see that there are some fundamental functions, defined strictly for internal use (convention: they start with ".") that are generics and depend on the kind of split in input. `R/split_funs.R` is very kind and group their generic definition at the beginning of the file. These functions are the main dispatcher for the majority of the split machinery. This is a clear example that shows how using `S4` logic helps clarity and flexibility in programming, allowing for easy extension of the program. For compactness we show also the `showMethods` result for each generic.

```{r, eval=FALSE}
setGeneric(".applysplit_rawvals",
           function(spl, df) standardGeneric(".applysplit_rawvals"))
# Browse[2]> showMethods(.applysplit_rawvals)
# Function: .applysplit_rawvals (package rtables)
# spl="AllSplit"
# spl="ManualSplit"
# spl="MultiVarSplit"
# spl="VAnalyzeSplit"
# spl="VarLevelSplit"
# spl="VarStaticCutSplit"
# Nothing here is inherited from the virtual class Split!!!

setGeneric(".applysplit_datapart",
           function(spl, df, vals) standardGeneric(".applysplit_datapart"))
# Same as .applysplit_rawvals

setGeneric(".applysplit_extras",
           function(spl, df, vals) standardGeneric(".applysplit_extras"))
# Browse[2]> showMethods(.applysplit_extras)
# Function: .applysplit_extras (package rtables)
# spl="AllSplit"
#     (inherited from: spl="Split")
# spl="Split"
# This means there is only a function for the virtual class Split!!!

setGeneric(".applysplit_partlabels",
           function(spl, df, vals, labels) standardGeneric(".applysplit_partlabels"))
# Browse[2]> showMethods(.applysplit_partlabels)
# Function: .applysplit_partlabels (package rtables)
# spl="AllSplit"
#     (inherited from: spl="Split")
# spl="MultiVarSplit"
# spl="Split"
# spl="VarLevelSplit"

setGeneric("check_validsplit", # our friend 
           function(spl, df) standardGeneric("check_validsplit"))
# Note: check_validsplit is an internal function but it is not excluded that one
#       day it will be exported. That is way it does not have the "." prefix.

setGeneric(".applysplit_ref_vals",
          function(spl, df, vals) standardGeneric(".applysplit_ref_vals"))
# Browse[2]> showMethods(.applysplit_ref_vals)
# Function: .applysplit_ref_vals (package rtables)
# spl="Split"
# spl="VarLevWBaselineSplit"

```

example with simple split

example with simple split function



Final examples with `MultiVarSplit` & `CompoundSplit`
These generics do different things for different classes. the power of S4
```{r, eval=FALSE}
setGeneric(".applysplit_rawvals", # these with dots are ONLY internals or for devs
           function(spl, df) standardGeneric(".applysplit_rawvals"))

setGeneric(".applysplit_datapart",
           function(spl, df, vals) standardGeneric(".applysplit_datapart"))

setGeneric(".applysplit_extras",
           function(spl, df, vals) standardGeneric(".applysplit_extras"))

setGeneric(".applysplit_partlabels",
           function(spl, df, vals, labels) standardGeneric(".applysplit_partlabels"))

setGeneric("check_validsplit", # may be useful to be called one day (not exported bc it may change)
           function(spl, df) standardGeneric("check_validsplit"))

setGeneric(".applysplit_ref_vals",
          function(spl, df, vals) standardGeneric(".applysplit_ref_vals"))
```
