---
title: "The Split Machinery"
author: "Davide Garolini"
date: '`r Sys.Date()`'
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{rtables Advanced Usage}
  %\VignetteEncoding{UTF-8}
  %\VignetteEngine{knitr::rmarkdown}
editor_options: 
  chunk_output_type: console
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```
## Disclaimer

This vignette is currently under development. Any code or prose which
appears in a version of this vignette on the `main` branch of the
repository will work/be correct, but they likely are not in their
final form.


# The Split Machinery

The scope of this vignette is understanding how `rtables` creates facets by splitting the incoming data into hierarchical groups that go from the root node to singular `rcell`s. The latter level, also called leaf-level, contains the final partition that is subjected to the analysis functions. More details from the user perspective can be found in relevant vignette `vignette("split_functions")` and function documentation like `?split_rows_by` and `?split_funcs`.

The following vignette will describe how the split machinery works for the row domain. Further information on how columns are defined will follow soon. 

NB: we must remind the reader that `rtables` is still under active development, and it has seen the efforts of multiple contributors across different years. Therefore, there may be legacy mechanisms and a couple of on-going transformations that could look different in the future.


## Process and Methods
(xxx reference to class vignette with this)

We invite the smart developer to use the provided examples as a way to get an "interactive" and dynamic vision of the internal algorithms, as they are routinely executed when constructing tables with `rtables`. This is achieved by using `browser()` and `debugonce()` on internal and exported functions (`rtables:::` or `rtables::`), as we will see in a moment. We invite also the continuous and autonomous exploration of the multiple `S3` and `S4` objects that constitute the complexity and power of `rtables`. To do so we will use the following useful functions:

* `methods(generic_function)`: This function lists the methods that are available for a generic function. Specifically for `S4` generic functions, `showMethods(generic_function)` is giving a more detailed information about each method (e.g. inheritance). 
* `class(object)`: This function returns the class of an object. If the class is not one of the built-in classes in R, you can use this information to search for its documentation and examples. Indeed, `help(class)` may be informative, as it will call the documentation of the specific class. Similarly, the `?` operator will call the disambiguation page that delivers you to different `S4` methods. For `S3` methods it is necessary to postfix the class name with a dot (e.g. `?summary.lm`).
* `getClass(class)`: This describes in a compact way the type of class, the slots that it has, and the relationships that it may have with the other classes that may inherit or be inherited by it. With `getClass(object)`, instead, we can see to which values the slots of the object are assigned. It is possible to use `str(object, max.level = 2)` to see a less formal and more compact descriptions of the slots, but it may be problematic when there are one or more objects in the class slots. Hence, the maximum number of level should always be limited to 2 or 3 (`max.level = 2`). Similarly, `attributes()` can be used to retrieve some information, but we need to remember that storing important variables in this way is not encouraged. Information regarding the type of class can be retrieved with `mode()` and indirectly by `summary()` and `is.S4()`.
*`getAnywhere(function)` is very useful to get the source code of internal functions and specific generics. It works very well with `S3` methods, and will in any case display for each of the found methods, its relevant namespace. Similarly, `getMethod(S4_generic, S4_class)` can retrieve the source code of `S4` methods that are specific to a class.
* `eval(debugcall(generic_function(obj)))`: this is a very useful way to browser a `S4` method defined specifically for a defined object without having to manually insert `browser()` into the code.

We explore and analyze the split machinery now with a growing amount of complexity, always following relevant functions and methods throughout their execution. By going from basic to complex and by discussing important and special cases, we hope to be able to give you a good understanding of how the split machinery works. 

In practice, the majority of the split engine resides in the source file `R/split_funs.R` with occasional incursion into `R/make_split_fun.R` for custom split function creation and rarer references to other more general tabulation files.


## `do_split`

The split machinery is so fundamental to `rtables` that relevant functions like `do_split` are executed, even when no split is requested. The following example shows how we can enter `do_split` and start understanding the class hierarchy and the main split engine.

```{r, message=FALSE}
library(rtables)
# debugonce(rtables:::do_split) # Uncomment me to enter the function!!!
basic_table() %>%
    build_table(DM)
```

In the following, we copied it so to allow the reader to go through the general structure with its enhanced comments and sections. Each section in the code reflects roughly a section of this vignette.

```{r, eval=FALSE}
### NB This is called at EACH level of recursive splitting
do_split <- function(spl,
                     df,
                     vals = NULL,
                     labels = NULL,
                     trim = FALSE,
                     spl_context) {
# CHECKS #
    ## This will error if, e.g., df does not have columns
    ##  required by spl, or generally any time the split (spl)
    ##  can not be applied to df
    check_validsplit(spl, df)
    
# SPLIT FUNCTION #
    ## In special cases, we need to partition data (split)
    ##  in a very specific way, e.g. depending on the data or 
    ##  external values. These can be achieved by using a custom
    ##  split function.
    
    ## note the <- here!!!
    if(!is.null(splfun <- split_fun(spl))) {
        ## Currently the contract is that split_functions take df, vals, labels and
        ## return list(values=., datasplit=., labels = .), optionally with
        ## an additional extras element
        if(func_takes(splfun, ".spl_context")) {
            ret <- tryCatch(splfun(df, spl, vals, labels, trim = trim,
                                   .spl_context = spl_context),
                            error = function(e) e) ## rawvalues(spl_context ))
        } else {
            ret <- tryCatch(splfun(df, spl, vals, labels, trim = trim),
                            error = function(e) e)
        }
        if(is(ret, "error")) {
            stop("Error applying custom split function: ", ret$message, "\n\tsplit: ",
                 class(spl), " (", payloadmsg(spl), ")\n",
                 "\toccured at path: ",
                 spl_context_to_disp_path(spl_context), "\n")
        }
    } else {
# .apply_split_inner #
        ## This is called when no split function is provided. Please note that also when provided,
        ##  this function will be probably called, as far as the main splitting method is not willingly
        ##  modified by the split function.
        ret <- .apply_split_inner(df = df, spl = spl, vals = vals, labels = labels, trim = trim)
    }

# EXTRA #
    ## this adds .ref_full and .in_ref_col
    if(is(spl, "VarLevWBaselineSplit"))
        ret <- .add_ref_extras(spl, df, ret)

# FIXUPVALS #
    ## this:
    ## - guarantees that ret$values contains SplitValue objects
    ## - removes the extras element since its redundant after the above
    ## - Ensures datasplit and values lists are named according to labels
    ## - ensures labels are character not factor
    ret <- .fixupvals(ret)
    
# RETURN #
    ret
}
```
We will see how input parameters are used and where. The most important ones are `spl` and `df`: the split objects and the input `data.frame`.


### Checks and Classes

We will start by looking at the first function called from `do_split`. This may give us a good overview of how the split itself is defined. This is, of course, the check-function (`check_validsplit`) that is used to verify if the split is valid for the data. In the following we will describe step-by-step the split-class hierarchy, but we invite the reader to explore this autonomously in future occasions. 

Lets then search the package for `check_validsplit`, you will find that it is defined as a generic in `R/split_funs.R`, where it is applied to the following "split" classes: `VarLevelSplit`, `MultiVarSplit`, `VAnalyzeSplit`, `CompoundSplit`, and `Split`. Another way to find this information, which is more useful for more spread out and complicated objects, is using `showMethods(check_validsplit)`. The virtual class `VAnalyzeSplit` (convention: it starts with "V") defines the main parent of analysis split which we discuss in detail in related vignette `vignette()` (xxx). From this, we can intuit that the `analyze()` calls actually mimic split objects as they create different results under a specific final split (or node). Now, notice that `check_validsplit` is also called in another location, i.e. in the main `R/tt_dotabulation.R` source file. This is again something related to making the "analyze" rows as it mainly checks for `VAnalyzeSplit` (link to tabulation dev guide xxx). We will discuss the other classes when they will appear in our examples (link to class hierarchy xxx). 

For the moment, we see with `class(spl)` (from the main `do_split` function) that we are dealing with an `AllSplit` object. By calling `showMethods(check_validsplit)` we will produce the following: 

```
Function: check_validsplit (package rtables)
spl="AllSplit"
    (inherited from: spl="Split")
spl="CompoundSplit"
spl="MultiVarSplit"
spl="Split"
spl="VAnalyzeSplit"
spl="VarLevelSplit"
```
It means that each of the listed classes has a dedicated definition of `check_validsplit` that may largely differ from the others. Only the class `AllSplit` does not have its own function definition as it is inherited from the `Split` class. Therefore, we understand that `AllSplit` is a class parent of `Split`. This is one of the first definition of a virtual class in the package and it is the only one that does not present the "V" prefix. Any of these classes are defined along with their constructor in `R/00tabletrees.R`. Reading how `AllSplit` is structured can be an useful example to understand how split objects are expected to work. Please see the comments in the following:

```{r, eval=FALSE}
setClass("AllSplit", contains = "Split")

AllSplit <- function(split_label = "",
                    cfun = NULL,
                    cformat = NULL,
                    cna_str = NA_character_,
                    split_format = NULL,
                    split_na_str = NA_character_,
                    split_name = NULL,
                    extra_args = list(),
                    indent_mod = 0L,
                    cindent_mod = 0L,
                    cvar = "",
                    cextra_args = list(),
                    ...) {
    if(is.null(split_name)) { # If the split has no name
        if(nzchar(split_label)) # (std is "")
            split_name <- split_label 
        else
            split_name <- "all obs" # Nor label, a standard split with all 
                                    # observations is assigned.
    }
    new("AllSplit", split_label = split_label,
        content_fun = cfun,
        content_format = cformat,
        content_na_str = cna_str,
        split_format = split_format,
        split_na_str = split_na_str,
        name = split_name,
        label_children = FALSE,
        extra_args = extra_args,
        indent_modifier = as.integer(indent_mod),
        content_indent_modifier = as.integer(cindent_mod),
        content_var = cvar,
        split_label_position = "hidden",
        content_extra_args = cextra_args,
        page_title_prefix = NA_character_,
        child_section_div = NA_character_)
}
```

We can see also print this information by calling `getClass("AllSplit")` for the general slot definition, or by calling `getClass(spl)` for having also all the values. Note that the first call will give also a lot of information about the class hierarchy. For more information regarding class hierarchy, please refer to the relevant vignette (xxx). We will discuss the majority of the slots by the end of this document. Now lets see if we can find some of the values described in the constructor in our object. To do so we will show here the more compact representation given by `str`. When there are multiple and hierarchical slots that contain objects themselves, calling `str` will be much less informative or not at all informative if the maximum level of nesting is not set (e.g. `max.level = 2`).

```{r, eval=FALSE}
Browse[2]> str(spl, max.level = 2)
Formal class 'AllSplit' [package "rtables"] with 17 slots
  ..@ payload                : NULL
  ..@ name                   : chr "all obs"
  ..@ split_label            : chr ""
  ..@ split_format           : NULL
  ..@ split_na_str           : chr NA
  ..@ split_label_position   : chr "hidden"
  ..@ content_fun            : NULL
  ..@ content_format         : NULL
  ..@ content_na_str         : chr NA
  ..@ content_var            : chr ""
  ..@ label_children         : logi FALSE
  ..@ extra_args             : list()
  ..@ indent_modifier        : int 0
  ..@ content_indent_modifier: int 0
  ..@ content_extra_args     : list()
  ..@ page_title_prefix      : chr NA
  ..@ child_section_div      : chr NA
```

Details about these slots will be necessary in future examples, and we will deal with them at that time. Now, we gave you a hint of the complex class hierarchy that makes up `rtables`, and how to explore it autonomously. Lets go forward in `do_split`. In our case, being `AllSplit` inherited from `Split`, we are sure that the called function will be the following (read the comment!):

```{r, eval=FALSE}
## default does nothing, add methods as they become
## required
setMethod("check_validsplit", "Split",
          function(spl, df)
    invisible(NULL))
```

### Split function and `.apply_split_inner`

Before diving into custom split functions we need to take a moment to analyze how `.apply_split_inner` works. This function is routinely called, also in the case we do have a split function. Lets see why this can be the case by entering it with `debugonce(.apply_split_inner)`. Of course, we are still browsing `do_split` in debug mode from the first example. We printed and commented it in the following:

```{r, eval=FALSE}
.apply_split_inner <- function(spl, df, vals = NULL, labels = NULL, trim = FALSE) {
    # - INPUTS - #
    # In this case .applysplit_rawvals will attempt finding the split values if vals is NULL.
    # Please notice that they might be a non-mutually exclusive set or subset of elements that
    # will constitute the split.
    
    # - SPLIT VALS - # 
    ## try to calculate values first. Most of the time we can
    if(is.null(vals))
        vals <- .applysplit_rawvals(spl, df)
    
    # - EXTRA PARAMETERS - #
    # This call extracts extra parameters from the split, according to the split values
    extr <- .applysplit_extras(spl, df, vals)

    # If there are no values to do the split upon, we return an empty final split
    if(is.null(vals)) {
        return(list(values = list(),
                    datasplit = list(),
                    labels = list(),
                    extras = list()))
    }

    # - DATA SUBSETTING - #
    dpart <- .applysplit_datapart(spl, df, vals)

    # - LABEL RETRIEVAL - #
    if(is.null(labels))
        labels <- .applysplit_partlabels(spl, df, vals, labels)
    else
        stopifnot(names(labels) == names(vals))
    
    # - TRIM - #
    ## get rid of columns that would not have any
    ## observations.
    ##
    ## But only if there were any rows to start with
    ## if not we're in a manually constructed table
    ## column tree
    if(trim) {
        hasdata <- sapply(dpart, function(x) nrow(x) > 0)
        if(nrow(df) > 0 && length(dpart) > sum(hasdata)) { #some empties
            dpart <- dpart[hasdata]
            vals <- vals[hasdata]
            extr <- extr[hasdata]
            labels <- labels[hasdata]
        }
    }

    # - ORDER RESULTS - #
    # Finds relevant order depending on spl_child_order()
    if(is.null(spl_child_order(spl)) || is(spl, "AllSplit")) {
        vord <- seq_along(vals)
    } else {
        vord <- match(spl_child_order(spl),
                     vals)
        vord <- vord[!is.na(vord)]
    }


    ## FIXME: should be an S4 object, not a list
    ret <- list(values = vals[vord],
               datasplit = dpart[vord],
               labels = labels[vord],
               extras = extr[vord])
    ret
}
```

After reading `.apply_split_inner`, we see that there are some fundamental functions, defined strictly for internal use (convention: they start with ".") that are generics and depend on the kind of split in input. `R/split_funs.R` is very kind and group their generic definition at the beginning of the file. These functions are the main dispatcher for the majority of the split machinery. This is a clear example that shows how using `S4` logic helps clarity and flexibility in programming, allowing for easy extension of the program. For compactness we show also the `showMethods` result for each generic.

```{r, eval=FALSE}
# Retrieves the values that will constitute the splits (facets), not necessarily a unique list.
# They could come from the data cuts for example -> it can be anything if it produces a set of strings.
setGeneric(".applysplit_rawvals", 
           function(spl, df) standardGeneric(".applysplit_rawvals"))
# Browse[2]> showMethods(.applysplit_rawvals)
# Function: .applysplit_rawvals (package rtables)
# spl="AllSplit"
# spl="ManualSplit"
# spl="MultiVarSplit"
# spl="VAnalyzeSplit"
# spl="VarLevelSplit"
# spl="VarStaticCutSplit"
# Nothing here is inherited from the virtual class Split!!!

# Contains the subset of the data (default, but these can overlap, can also NOT be mutually exclusive).
setGeneric(".applysplit_datapart",
           function(spl, df, vals) standardGeneric(".applysplit_datapart"))
# Same as .applysplit_rawvals

# Extract the extra parameter for the split
setGeneric(".applysplit_extras",
           function(spl, df, vals) standardGeneric(".applysplit_extras"))
# Browse[2]> showMethods(.applysplit_extras)
# Function: .applysplit_extras (package rtables)
# spl="AllSplit"
#     (inherited from: spl="Split")
# spl="Split"
# This means there is only a function for the virtual class Split. 
#  So all splits behaves the same!!!

# Split label retrieval and assignment if visible.
setGeneric(".applysplit_partlabels",
           function(spl, df, vals, labels) standardGeneric(".applysplit_partlabels"))
# Browse[2]> showMethods(.applysplit_partlabels)
# Function: .applysplit_partlabels (package rtables)
# spl="AllSplit"
#     (inherited from: spl="Split")
# spl="MultiVarSplit"
# spl="Split"
# spl="VarLevelSplit"

setGeneric("check_validsplit", # our friend 
           function(spl, df) standardGeneric("check_validsplit"))
# Note: check_validsplit is an internal function but it is not excluded that one
#       day it will be exported. That is way it does not have the "." prefix.

setGeneric(".applysplit_ref_vals",
          function(spl, df, vals) standardGeneric(".applysplit_ref_vals"))
# Browse[2]> showMethods(.applysplit_ref_vals)
# Function: .applysplit_ref_vals (package rtables)
# spl="Split"
# spl="VarLevWBaselineSplit"

```

Now, we know that `.applysplit_extras` is the function that will be called first because we did not specify any `vals` and it is therefore `NULL`. This is a generic function as it can be seen by `showMethod(.applysplit_extras)`. It is indeed an `S4` generics and its source code can be determined by the following:

```{r, eval=FALSE}
Browse[3]> getMethod(".applysplit_rawvals", "AllSplit")
Method Definition:

function (spl, df) 
obj_name(spl)
<bytecode: 0x55f37d386cc0>
<environment: namespace:rtables>

Signatures:
        spl       
target  "AllSplit"
defined "AllSplit"

# What is obj_name -> slot in spl
Browse[3]> obj_name(spl)
[1] "all obs"

# coming from
Browse[3]> getMethod("obj_name", "Split")
Method Definition:

function (obj) 
obj@name ##### Slot that we could see from str(spl, max.level = 2)
<bytecode: 0x55f37dec7ac0>
<environment: namespace:rtables>

Signatures:
        obj    
target  "Split"
defined "Split"
```

Then we have `.applysplit_extras` that will be covered in later sections and simply extracts the extra arguments from the split objects and assign them to their relative split values. If no split values are still available, the function will exit here with an empty split. Otherwise the data will be divided in different splits or data subsets (facets) with `.applysplit_datapart`. In our current example the resulting list comprises the whole input data set (i.e. do `getMethod(".applysplit_datapart", "AllSplit")` and a list will be evident: `function (spl, df, vals) list(df)`).

Next, split labels are checked. If they are not present split values (`vals`) will be used with `.applysplit_partlabels` that, in the case of it being applied to a `Split` object, it translates into `as.character(vals)`. Otherwise, the inserted labels are checked against the name of split values.

Lastly, the split values are ordered on the basis of `spl_child_order`. In our case, which concerns the general `AllSplit`, the sorting will not happen, i.e. it will be simply dependent on the number of split values `seq_along(vals)`.

#### A simple split

In the following, we demonstrate how row splits work according to the features that we have already described. We add two splits and see how `do_split` behavior changes. Note that if we do not add an `analyze` call, the split will behave as before, giving an empty table with all observations. As default, calling `analyze` on a variable will produce a mean for each data subset that has been generated by the splits. We want to go beyond the first call (xxx, why??) of `do_split` that is by design on all observation with the purpose of generating the root split that contains all data. To achieve this goal we need to use `debug(fnc)` instead of `debugonce(fnc)` as we will need to step in each of the splits.

```{r, message=FALSE}
library(rtables)
library(dplyr)
# This filter is added to avoid having too many calls to do_split
DM_tmp <- DM %>% 
    filter(SEX %in% c("M", "F")) %>% 
    mutate(SEX = factor(SEX)) # to drop unattended levels

# debug(rtables:::do_split) # Uncomment me to enter the function!!!
basic_table() %>%
    split_rows_by("SEX") %>% 
    split_rows_by("ARM") %>% 
    analyze("BMRKR1") %>% # analysis is needed to produce the splits !!
    build_table(DM_tmp) 
# undebug(rtables:::do_split) # reset the debug mode
```

Now, we might want to check the formal class of `spl` before anything else.

```{r, eval=FALSE}
Browse[2]> str(spl, max.level = 2)
Formal class 'VarLevelSplit' [package "rtables"] with 20 slots
  ..@ value_label_var        : chr "SEX"
  ..@ value_order            : chr [1:4] "F" "M" "U" "UNDIFFERENTIATED"
  ..@ split_fun              : NULL
  ..@ payload                : chr "SEX"
  ..@ name                   : chr "SEX"
  ..@ split_label            : chr "SEX"
  ..@ split_format           : NULL
  ..@ split_na_str           : chr NA
  ..@ split_label_position   : chr "hidden"
  ..@ content_fun            : NULL
  ..@ content_format         : NULL
  ..@ content_na_str         : chr NA
  ..@ content_var            : chr ""
  ..@ label_children         : logi NA
  ..@ extra_args             : list()
  ..@ indent_modifier        : int 0
  ..@ content_indent_modifier: int 0
  ..@ content_extra_args     : list()
  ..@ page_title_prefix      : chr NA
  ..@ child_section_div      : chr NA
```

From this, we can directly infer that the class is different now (`VarLevelSplit`) and understand that the split label will be hidden (`split_label_position` slot). Moreover, we see a specific value order with specific split values. Also, `VarLevelSplit` seems to have three more slots than `AllSplit`. What are they precisely?

```{r, eval=FALSE}
slots_as <- getSlots("AllSplit") # inherits virtual class Split and is general class for all splits
# getClass("CustomizableSplit") # -> Extends: "Split", Known Subclasses: Class "VarLevelSplit", directly
slots_cs <- getSlots("CustomizableSplit") 
slots_vls <- getSlots("VarLevelSplit")

slots_cs[!(names(slots_cs) %in% names(slots_as))]
#        split_fun 
# "functionOrNULL" 
slots_vls[!(names(slots_vls) %in% names(slots_cs))]
# value_label_var     value_order 
#     "character"           "ANY"
```

Remember always to check the constructor and class definition inside `R/00tabletrees.R` if exploratory tools do not suffice. Now, `check_validsplit(spl, df)` will dispatch to a different method than before (`getMethod("check_validsplit", "VarLevelSplit")`). Indeed, it uses the internal utility function `.checkvarsok` to check if the `vars`, i.e. the `payload` is actually present in `names(df)`.

Now, the next relevant function will be `.apply_split_inner` where we want to see exactly what changes (`debugonce(.apply_split_inner)`). Of course, this function is directly called as no custom split function is provided. Being parameter `vals` not specified (`NULL`), the split values are retrieved from `df` by using the split payload to select specific columns (`varvec <- df[[spl_payload(spl)]]`). Every time no split values are specified, they will be retrieved from the selected column as unique values, if character, or levels, if factor. 

Next, `.applysplit_datapart` creates a named list of facets or data subsets. In this case, the result is actually a mutually exclusive partition of the data. `.applysplit_partlabels` is a bit less linear as it has to take into account the possibility of having specified labels in the payload (xxx). Beside looking at the function source code with `getMethod(".applysplit_partlabels", "VarLevelSplit")`, we can enter in debugging mode the `S4` generic function as follows:

```{r, eval=FALSE}
eval(debugcall(.applysplit_partlabels(spl, df, vals, labels)))
# We leave to the smart developer to see how the labels are assigned

# PS: remember to undebugcall() similarly
```
In our case, the final labels are `vals` as nothing different was specified. Their order is retrieved from the split object (`spl_child_order(spl)`) and matched with current split values. The returned list is then processed as it was before.

If we continue with the next call of `do_split`, the same procedure is accomplished for the second `ARM` split. This is done on the partition that was already done in the first split. The only give out of this is the fact that the main `df` is constituted by a subset (facet) of the total data, according to the first split. This will be done iteratively for as many data split as requested. Before concluding this iteration, we take a moment to talk a bit more in detail about how `.fixupvals(partinfo)` works. It is not a generic function and the source code can be easily accessed as follows. We will not describe this into details, but we suggest to run through it with `debugonce(.fixupvals)` to understand what it does in practice.

```{r, eval=FALSE}
# Note: comments are added to enhance readability
Browse[2]> .fixupvals
function(partinfo) {
    # Guarantee of character labels
    if(is.factor(partinfo$labels))
        partinfo$labels <- as.character(partinfo$labels)

    # General import of values (in theory this may be an S4 obj in the future)
    vals <- partinfo$values
    if(is.factor(vals))
        vals <- levels(vals)[vals]
    extr <- partinfo$extras
    dpart <- partinfo$datasplit
    labels <- partinfo$labels
    
    # Assigning labels at any cost
    if(is.null(labels)) {
        if(!is.null(names(vals)))
            labels <- names(vals)
        else if(!is.null(names(dpart)))
            labels <- names(dpart)
        else if (!is.null(names(extr)))
            labels <- names(extr)
    }

    if(is.null(vals) && !is.null(extr))
        vals <- seq_along(extr)
    
    # No split will happen as there are no split values
    if(length(vals) == 0) {
        stopifnot(length(extr) == 0)
        return(partinfo)
    }
    ## length(vals) > 0 from here down

    if(are(vals, "SplitValue") && !are(vals, "LevelComboSplitValue")) {
        if(!is.null(extr)) {
            warning("Got a partinfo list with values that are ",
                    "already SplitValue objects and non-null extras ",
                    "element. This shouldn't happen")
        }
    } else {
        # reformatting of extra args
        if(is.null(extr))
            extr <- rep(list(list()), length(vals))
# --->  # Main list of SplitValue objects: iterative call of new("SplitValue", value = val, extra = extr, label = label)
        vals <- make_splvalue_vec(vals, extr, labels = labels)
    }
    ## we're done with this so take it off (it is already in SplitValue)
    partinfo$extras <- NULL

    vnames <- value_names(vals)
    names(vals) <- vnames
    partinfo$values <- vals

    if(!identical(names(dpart), vnames)) {
        names(dpart) <- vnames
        partinfo$datasplit <- dpart
    }


    partinfo$labels <- labels
    
    # Check to have only single elements in partinfo (xxx)
    stopifnot(length(unique(sapply(partinfo, NROW))) == 1)
    partinfo
```

#### Alreadymade split functions

We start with a custom split function that is already defined in `rtables`. Its scope is filtering out specific values as follows:
```{r, message=FALSE}
library(rtables)
# debug(rtables:::do_split) # uncomment to see into the main split function
basic_table() %>%
    split_rows_by("SEX", split_fun = drop_split_levels) %>% 
    split_rows_by("ARM") %>% 
    analyze("BMRKR1") %>%
    build_table(DM)
# undebug(rtables:::do_split)

# PS: this produces the same output as before with the filters
```
After skipping the root split, we enter the split based on column `SEX`. As we specified a split function, we entered the following code block:
```{r, eval=FALSE}
# Note: the spl object still belongs to VarLevelSplit class
  ## note the <- here!!! # Extracts the split function from split object
    if(!is.null(splfun <- split_fun(spl))) { 
        ## Currently the contract is that split_functions take df, vals, labels and
        ## return list(values=., datasplit=., labels = .), optionally with
        ## an additional extras element # passed through by means of spl object
        if(func_takes(splfun, ".spl_context")) { # Does splfun have .spl_context??
            # Does splfun use the .spl_context (which is always there, now as root)
            ret <- tryCatch(splfun(df, spl, vals, labels, trim = trim,
                                   .spl_context = spl_context),
                            error = function(e) e) ## rawvalues(spl_context ))
        } else {
            ret <- tryCatch(splfun(df, spl, vals, labels, trim = trim),
                            error = function(e) e)
        }
        if(is(ret, "error")) {
            stop("Error applying custom split function: ", ret$message, "\n\tsplit: ",
                 class(spl), " (", payloadmsg(spl), ")\n",
                 "\toccured at path: ",
                 spl_context_to_disp_path(spl_context), "\n")
        }
    } # etc...
```

Here, we invite to always keep a keen eye on `spl_context`, as it is fundamental for more sophisticate splits, e.g. in the cases where the split itself depends mainly on preceding splits or values. Please, when the split function is called, take a moment to look at how `drop_split_levels` is built. You will see that it is fundamentally a wrapper of `.apply_split_inner` that drops empty factor levels, therefore avoiding empty split.

```{r, eval=FALSE}
> drop_split_levels
function(df,
                              spl,
                              vals = NULL,
                              labels = NULL,
                              trim = FALSE) {
    # Retrieve split column
    var <- spl_payload(spl)
    df2 <- df
    
    ## This call is exactly the one we did in the filtering to get rid of empty levels
    df2[[var]] <- factor(df[[var]])
    
    ## Our main function!
    .apply_split_inner(spl, df2, vals = vals,
                       labels = labels,
                       trim = trim)
}
```
#### Custom split functions


### Extra arguments - `extra_args`
(xxx - `analyze_colvars(my_afun, extra_args = list(ref_rowgroup = "V1"))`)


### (xxx - the other parameters... trim??)

Final examples with `MultiVarSplit` & `CompoundSplit`

