---
title: "Tabulation"
author: "Davide Garolini"
date: '`r Sys.Date()`'
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{rtables Advanced Usage}
  %\VignetteEncoding{UTF-8}
  %\VignetteEngine{knitr::rmarkdown}
editor_options: 
  chunk_output_type: console
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```
## Disclaimer

Any code or prose which appears in a version of this vignette on the `main` branch of the repository may reflect a specific state of things that can be more or less recent. This guide reflects very important pieces of the split machinery that are unlikely to change. We anyway invite the reader to think always that the current code may have drifted from the following document, and it is always the best practice to read directly the code on `main`. (xxx we should insert it automatically)

# Tabulation

Tabulation in `rtables` is a process that takes a pre-defined layout and applies it to the data. The layout object, with all its splits (see `vignette("dg_split_machinery")`) and `analyze`s, can be applied to different data to produce valid tables. This process is happening principally inside the file `tt_dotabulation.R` and its principal user-facing function `build_table` that resides in it. We will sometimes see functions and methods that are present in other files like `colby_construction.R`. We assume any reader is already familiar with the documentation related to `build_table`. Also, we suggest reading first the vignette regarding the split machinery (`vignette("dg_split_machinery")`), as it is instrumental in understanding how the layout object, which is built principally of splits, is tabulated when data is applied.

This time, we enter in _medias res_ into `build_table` to see how it is meant to work.

```{r, eval=FALSE}
# rtables 6.2.0
debugonce(build_table)

# A very simple layout
lyt <- basic_table() %>% 
    split_rows_by("STRATA1") %>% 
    split_rows_by("SEX", split_fun = drop_split_levels) %>% 
    split_cols_by("ARM") %>% 
    analyze("BMRKR1")
# lyt must be a PreDataTableLayouts object
is(lyt, "PreDataTableLayouts")

lyt %>% build_table(DM)

```

Now lets see the interior of our `build_table`, After initial check that the layout is a pre-data table layout, it is checked if the coulmn layout is defined (`clayout` accessor), i.e. it does not have any column split. If that is the case, a `All obs` column is added automatically with all observations. After this, there are a couple of defensive programming calls that do checks and fixtures as we finally have the data. These divide in two kinds: the one that are mainly concerning the layout, which are defined as generics and the one concerning the data that is instead a function as it is not dependent on the layout class. Indeed, the layout is structured and can be divided in `clayout` and `rlayout` (column and row layout). The first one is used to create `cinfo` which is the general object and container of the column splits and information. The second one contains the obligatory all data split, i.e. the root split (accessible with `root_spl`), and the row splits' vectors which are iterative splits in the row space. In the following we consider first the checks and defensive programming.
```{r, eval=FALSE}
    ## do checks and defensive programming now that we have the data
    lyt <- fix_dyncuts(lyt, df) # now that I have the data, I create the splits
    lyt <- set_def_child_ord(lyt, df) # with the data I set the same order for all splits
    lyt <- fix_analyze_vis(lyt) # checks if the analyze last split should be visible
    df <- fix_split_vars(lyt, df, char_ok = is.null(col_counts)) 
    # checks if split vars are present
    
    lyt[] # preserve names and it is just warning if longer
    lyt@.Data # might not preserve the names -> xxx fixme comment there
    # Do extensive testing about these behaviors
```