---
title: "Tabulation"
author: "Davide Garolini"
date: '`r Sys.Date()`'
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{rtables Advanced Usage}
  %\VignetteEncoding{UTF-8}
  %\VignetteEngine{knitr::rmarkdown}
editor_options: 
  chunk_output_type: console
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```
## Disclaimer

Any code or prose which appears in a version of this vignette on the `main` branch of the repository may reflect a specific state of things that can be more or less recent. This guide reflects very important pieces of the split machinery that are unlikely to change. We anyway invite the reader to think always that the current code may have drifted from the following document, and it is always the best practice to read directly the code on `main`. (xxx we should insert it automatically)

# Tabulation

Tabulation in `rtables` is a process that takes a pre-defined layout and applies it to the data. The layout object, with all its splits (see `vignette("dg_split_machinery")`) and `analyze`s, can be applied to different data to produce valid tables. This process is happening principally inside the file `tt_dotabulation.R` and its principal user-facing function `build_table` that resides in it. We will sometimes see functions and methods that are present in other files like `colby_construction.R` or `make_subset_expr.R`. We assume any reader is already familiar with the documentation related to `build_table`. Also, we suggest reading first the vignette regarding the split machinery (`vignette("dg_split_machinery")`), as it is instrumental in understanding how the layout object, which is built principally of splits, is tabulated when data is applied.

This time, we enter in _medias res_ into `build_table` to see how it is meant to work.

```{r, eval=FALSE}
# rtables 6.2.0
library(rtables)
debugonce(build_table)

# A very simple layout
lyt <- basic_table() %>% 
    split_rows_by("STRATA1") %>% 
    split_rows_by("SEX", split_fun = drop_split_levels) %>% 
    split_cols_by("ARM") %>% 
    analyze("BMRKR1")
# lyt must be a PreDataTableLayouts object
is(lyt, "PreDataTableLayouts")

lyt %>% build_table(DM)

```

Now lets see the interior of our `build_table`, After initial check that the layout is a pre-data table layout, it is checked if the coulmn layout is defined (`clayout` accessor), i.e. it does not have any column split. If that is the case, a `All obs` column is added automatically with all observations. After this, there are a couple of defensive programming calls that do checks and fixtures as we finally have the data. These divide in two kinds: the one that are mainly concerning the layout, which are defined as generics and the one concerning the data that is instead a function as it is not dependent on the layout class. Indeed, the layout is structured and can be divided in `clayout` and `rlayout` (column and row layout). The first one is used to create `cinfo` which is the general object and container of the column splits and information. The second one contains the obligatory all data split, i.e. the root split (accessible with `root_spl`), and the row splits' vectors which are iterative splits in the row space. In the following we consider first the checks and defensive programming.
```{r, eval=FALSE}
    ## do checks and defensive programming now that we have the data
    lyt <- fix_dyncuts(lyt, df) # Now that I have the data, I create the splits that depends on data
    lyt <- set_def_child_ord(lyt, df) # With the data I set the same order for all splits
    lyt <- fix_analyze_vis(lyt) # Checks if the analyze last split should be visible
    # If there is only one you will not get the variable name otherwise you get it if you
    # have multivar. Default is NA. You can do it now only because you are sure to
    # have the whole layout.
    df <- fix_split_vars(lyt, df, char_ok = is.null(col_counts)) 
    # checks if split vars are present
    
    lyt[] # preserve names and it is just warning if longer, and repeats the value if only one
    lyt@.Data # might not preserve the names # it works only when it is another class that inherits from lists
    # We suggest to do extensive testing about these behaviors in order to do choose
    # the appropriate one
```
Along the various checks and defensive programming, we found `PreDataAxisLayout` which is a virtual class that both row and cols layouts inherit from. Virtual classes are handy for group classes that need to share common things like labels or functions that need to be applicable to their relative classes. Check more information about `rtables` class hierarchy in the dedicated dev vignette (xxx add).

Now, we continue with `build_table`. We notice after the checks `TreePos()` which is a constructor for an oject that retains a representation of the tree position along with split values and labels. This is mainly used by `create_colinfo` that we decide to enter now with `debugonce(create_colinfo)`. This function creates the object that represent the column splits and everything else that may be related with the columns. In particular, in this function the column counts are calculated. The parameter inputs are as follows:

```{r, eval=FALSE}
cinfo <- create_colinfo(lyt, # Main layout with col splits info
                        df, # df used for splits and col counts if no alt_counts_df is present
                        rtpos, # TreePos (does not change in out of this function)
                        counts = col_counts, # If we want to overwrite the calculations with df/alt_counts_df
                        alt_counts_df = alt_counts_df, # alternative data for col counts
                        total = col_total, # calculated from build_table inputs (nrow of df or alt_counts_df)
                        topleft) # topleft information added into build_table
```

`create_colinfo` is in `make_subset_expr.R`. Here, we see that if `topleft` is present in `build_table`, it will override the one in `lyt`. Entering `create_colinfo`, we will see the following calls:
```{r, eval=FALSE}

    clayout <- clayout(lyt) # Extracts column split and info
    if(is.null(topleft))
        topleft <- top_left(lyt) # If top_left is not present in build_table, it is took from lyt
    ctree <- coltree(clayout, df = df, rtpos = rtpos) # Main constructor of LayoutColTree 
    # The above is referenced as generic and principally represented as 
    # setMethod("coltree", "PreDataColLayout", (located in `tree_accessor.R`).
    # This is a call that restructure information from clayout and df and rtpos to get a more compact column tree
    # layout. Part of this design is related to past implementations.

    cexprs <- make_col_subsets(ctree, df) # extracts expressions in a compact fashion. WARNING, removing NAs at this step
                                          # is automatic. This should be coupled with a warning for NAs in the split (xxx)
    colextras <- col_extra_args(ctree) # retrieves extra_args from the tree. It may be not used

```

Next in the function there is the creation of the column counts. For now this happens only at the leaf level but it can be certainly calculated for all levels independently (this is current issue in `rtables`, i.e. how to print other levels' totals). Precedence for col counts may be not documented (xxx todo). Original use case is that you split events while the column counts is the number of patients and not events. First only counts as vector was added, but it is often the case that you have the possibility to add `alt_counts_df`. Finally the `cinfo` object is created (`InstantiatedColumnInfo`) with all the above information.

Now, if we continue in `build_table` we hit `.make_ctab` for a root split. This is a general initial value that produces the root split as a content row. Indeed `ctab` stays for content row which is a row that has only a label in it. From the documentation regarding `summarize_row_groups`, you know that this is the way `rtables` defines label rows, as content rows. `.make_ctab` is very close to the actual creation of the table row which is done with `.make_tablerows`. This function also uses `parent_cfun` and `.make_caller` to retrieve the content function inserted in above levels